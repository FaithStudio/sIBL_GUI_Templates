[Template]
Name = @Name | Softimage Mental Ray Standard | String | Template Name
Path = @Path | | String | Template Path
HelpFile = @HelpFile | help/Softimage_MR_Standard_Template_Manual.html | String | Help File
Release = @Release | 2.0.7 | String | Template
Date = @Date | 29 November 2012 | String | Date
Author = @Author | Kel Solaar | String | Author
Email = @Email | thomas.mansencal@gmail.com | String | Email
Url = @Url | http://thomasmansencal.com/ | String | Url
Software = @Software | Softimage | String | Software
Version = @Version | 2011 - 2013 | String | Version
Renderer = @Renderer | Mental Ray | String | Renderer
OutputScript = @OutputScript | sIBL_XSI_Import.js | String | Output Script
Comment = @Comment | This is Softimage Mental Ray Template. | String | Comment

[Ibl Set Attributes]
Background|BGfile = @BGfile
Reflection|REFfile = @REFfile
Reflection|REFmulti = @REFmulti
Reflection|REFgamma = @REFgamma
Enviroment|EVfile = @EVfile
Enviroment|EVmulti = @EVmulti
Enviroment|EVgamma = @EVgamma
Sun|SUNu = @SUNu
Sun|SUNv = @SUNv
Sun|SUNcolor = @SUNcolor
Sun|SUNmulti = @SUNmulti
Lights|DynamicLights = @dynamicLights
Header|Height = @Height
Header|North = @North

[Common Attributes]
sceneSetupPrefix = @sceneSetupPrefix | sIBL | String | Scene Setup Prefix
createBackground = @createBackground | 1 | Boolean | Create / Update Background
createReflection = @createReflection | 1 | Boolean | Create / Update Reflection
createLighting = @createLighting | 1 | Boolean | Create / Update Lighting
createSun = @createSun | 1 | Boolean | Create / Update Sun
createLights = @createLights | 1 | Boolean | Create Dynamic Lights

[Additional Attributes]
showPassesDialog = @showPassesDialog | 0 | Boolean | Passes Selection Dialog
updateScene = @updateScene | 0 | Boolean | Update Scene
overrideTweaks = @overrideTweaks | 0 | Boolean | Override User Tweaks
displayFeedback = @displayFeedback | 1 | Boolean | Display Feedback
sunLightType = @sunLightType | Infinite;Light Box;Spot;Point | Enum | Sun Light Type
dynamicLightsType = @dynamicLightsType | Infinite;Light Box;Spot;Point | Enum | Dynamic Lights Type
hideLights = @hideLights | 1 | Boolean | Hide Lights
createGround = @createGround | 1 | Boolean | Create Ground
shadowCatcher = @shadowCatcher | 1 | Boolean | Ground Shadow Catcher
physicalSun = @physicalSun | 1 | Boolean | Physical Sun
activateFinalGather = @activateFinalGather | 1 | Boolean | Activate Final Gather
activateColorManagement = @activateColorManagement | 1 | Boolean | Activate Color Management

[Remote Connection]
ConnectionType = @ConnectionType | Socket | String | Connection Type
ExecutionCommand = @ExecutionCommand | $loaderScriptPath | String | Execution Command
DefaultAddress = @DefaultAddress | 127.0.0.1 | Integer | Default Address
DefaultPort = @DefaultPort | 12288 | Integer | Default Port

[Script]
// @OutputScript - @Release for @Software @Version
// Author: @Author
// EMail: @Email
// Homepage: @Url
// Template path: @Path
// Template last modified: @Date
// sIBL_GUI
function __constants()
{
	this.applicationName = "sIBL_GUI";
	this.prefix = "@sceneSetupPrefix";
	this.package = "@Software".replace(" ", "_");
	this.renderer = "@Renderer".replace(" ", "_");
	this.packagePrefix = this.prefix + this.package;
	this.packageRendererPrefix = this.prefix + this.package + this.renderer;
	this.title = "Smart IBL";
	this.controlsTitle = this.title.replace(" ", "_") + "_Controls";
	this.defaultGamma = 2.2;
	if(commandExists("sIBL_XSI_preProcessCommand"))
		this.globalPreProcessCommand = function() {sIBL_XSI_preProcessCommand();};
	else
		this.globalPreProcessCommand = null;
	if(commandExists("sIBL_XSI_postProcessCommand"))
		this.globalPostProcessCommand = function() {sIBL_XSI_postProcessCommand();};
	else
		this.globalPostProcessCommand = null;
	if(commandExists("sIBL_XSI_MR_preProcessCommand"))
		this.localPreProcessCommand = function() {sIBL_XSI_MR_preProcessCommand();};
	else
		this.localPreProcessCommand = null;
	if(commandExists("sIBL_XSI_MR_postProcessCommand"))
		this.localPostProcessCommand = function() {sIBL_XSI_MR_postProcessCommand();};
	else
		this.localPostProcessCommand = null;
}
var Constants = new __constants();

function convertInputColors(color)
{
	if(color == [-1])
		return color;

	for(var i = 0; i < color.length; i++)  
    	color[i] = color[i] / 255.0;
	
	if(@activateColorManagement)
		for(var i = 0; i < color.length; i++)  
    		color[i] = Math.pow(color[i], Constants.defaultGamma)

	return color;
}

function Light(name, color, multiplier, uCoordinate, vCoordinate)
{
	this.name = name;
	this.color = color;
	this.multiplier = multiplier;
	this.uCoordinate = uCoordinate;
	this.vCoordinate = vCoordinate;
}

function parseDynamicLightsAttribute(data)
{
	if(data == [-1])
		return data;

	var	dynamicLights = [];
	var data = data.split("|");
	for(var i = 0; i < data.length; i += 8)
		dynamicLights[dynamicLights.length] = new Light(Constants.prefix + "_DKL_" + data[i + 1], convertInputColors([parseFloat(data[i + 2]), parseFloat(data[i + 3]), parseFloat(data[i + 4])]), parseFloat(data[i + 5]), parseFloat(data[i + 6]), parseFloat(data[i + 7]));
	return dynamicLights;
}

function __data()
{
	this.backgroundFilePath = "@BGfile";
	this.reflectionFilePath = "@REFfile";
	this.reflectionMultiplier = @REFmulti;
	this.reflectionGamma = @REFgamma;
	this.lightingFilePath = "@EVfile";
	this.lightingMultiplier = @EVmulti;
	this.lightingGamma = @EVgamma;
	this.sunU = @SUNu;
	this.sunV = @SUNv;
	this.sunColor = convertInputColors([@SUNcolor]);
	this.sunMultiplier = @SUNmulti;
	this.dynamicLights = parseDynamicLightsAttribute("@dynamicLights");
	this.height = @Height;
	this.north = @North;
}
var Data = new __data();

function __options()
{
	this.createBackground = @createBackground;
	this.createReflection = @createReflection;
	this.createLighting = @createLighting;
	this.createSun = @createSun;
	this.createLights = @createLights;
	this.showPassesDialog = @showPassesDialog;
	this.updateScene = @updateScene;
	this.overrideTweaks = @overrideTweaks;
	this.displayFeedback = @displayFeedback;
	this.feedbackRadius = 100;
	this.sunLightType = "@sunLightType";
	this.dynamicLightsType = "@dynamicLightsType";
	this.hideLights = @hideLights;
	this.createGround = @createGround;
	this.shadowCatcher = @shadowCatcher;
	this.physicalSun = @physicalSun;
	this.activateFinalGather = @activateFinalGather;
	this.activateColorManagement = @activateColorManagement;
}
var Options = new __options();

var proceedSetup = true;
if(Data.backgroundFilePath == "-1" || Data.reflectionFilePath == "-1" || Data.lightingFilePath == "-1")
{
	var result = XSIUIToolkit.Msgbox(Constants.applicationName + " | Non Template compatible Ibl Set provided: Unpredictable results may occur! Would you like to proceed anyway?", siMsgYesNo | siMsgQuestion, Constants.applicationName);
	if (result == siMsgNo )
		proceedSetup = false;
}
if(proceedSetup)
	setup();
else
	LogMessage(Constants.applicationName + " | '" + Constants.title + "' file import aborted!");

function setup()
{
	try
	{
		if(Constants.globalPreProcessCommand)
		{
			LogMessage(Constants.applicationName + " | Executing overall preprocess Command!");
			Constants.globalPreProcessCommand()
		}

		if(Constants.localPreProcessCommand)
		{
			LogMessage(Constants.applicationName + " | Executing Template specific preprocess Command!");
			Constants.localPreProcessCommand()
		}

		// Storing Active Layer.
		var layer = ActiveProject.ActiveScene.ActiveLayer;

		var selectedPasses = [];

		if(Options.showPassesDialog)
			selectedPasses = getPasses();
		else
			selectedPasses[0] = GetCurrentPass();

		if(selectedPasses != null)
		{

			if(selectedPasses.length != 0)
			{
				var progressBar = XSIUIToolkit.ProgressBar;
				progressBar.Maximum = 100;
				progressBar.CancelEnabled = false;

				// Defines Sun And Dynamic Lights Existence From Ibl file.
				if(Data.sunU != -1 && Data.sunV != -1)
					var sunExists = true;
				else
					var sunExists = false;

				if(Data.dynamicLights != -1)
					var dynamicLightsExists = true
				else
					var dynamicLightsExists = false

				if(Options.updateScene)
				{
					LogMessage(Constants.applicationName + " | Starting '" + Constants.prefix + "' related nodes update!");
					progressBar.Caption = Constants.applicationName + " | Updating Scene!";

					var controlsGroup = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix, true);
					controlsGroup = controlsGroup(0);

					if(controlsGroup != null)
					{
						scriptEditorVerbose(false);
						autoInspectState(false);

						progressBar.Step = 16.666;
						progressBar.Visible = true;

						// Scene Cleanup.
						update_environmentDeletion();
						progressBar.Increment();

						// Defines Updated Feedback Radius From Scene Extent.
						Options.feedbackRadius = update_getExtendedFeedbackRadius();

						// Environment Shaders Update.
						update_environmentShaders(selectedPasses);
						progressBar.Increment();

						// Feedback Update.
						if(Options.overrideTweaks)
							update_feedback();
						progressBar.Increment();

						// Sun Update.
						if(sunExists)
						{
							if(Options.createSun)
							{
								update_sun();
							}
						}
						progressBar.Increment();

						// Dynamic Lights Update.
						if(dynamicLightsExists)
						{
							if(Options.createLights)
							{
								update_dynamicsLights();
							}
						}
						progressBar.Increment();

						if(Options.createGround)
						{
							update_ground();
						}
						progressBar.Increment();

						progressBar.Visible = false;
					}
					else
					{
						LogMessage(Constants.applicationName + " | No '" + Constants.prefix + "' group found, aborting scene update!", siWarning);
					}

				}
				else
				{
					LogMessage(Constants.applicationName + " | Starting '" + Constants.title + "' file import!");
					progressBar.Caption = Constants.applicationName + " | Importing '" + Constants.title + "' file!";

					scriptEditorVerbose(false);
					autoInspectState(false);

					progressBar.Step = 11;
					progressBar.Visible = true;

					// Scene Cleanup.
					environmentDeletion();
					progressBar.Increment();

					// Defines Feedback Radius From Scene Extent.
					Options.feedbackRadius = getExtendedFeedbackRadius();

					// Activating Renderer.
					setRenderer();
					progressBar.Increment();

					// Lights Hide.
					if(Options.hideLights)
						hideSceneLights();
					progressBar.Increment();

					// Environment Shaders Creation.
					getEnvironmentShaders(selectedPasses);
					progressBar.Increment();

					// Feedback Creation.
					getFeedback();
					progressBar.Increment();

					// Sun Creation.
					if(sunExists)
					{
						if(Options.createSun)
						{
							if(objectExists(Constants.prefix + "_Feedback"))
							{
								getSun();
							}
						}
					}
					progressBar.Increment();

					// Dynamic Lights Creation.
					if(dynamicLightsExists)
					{
						if(Options.createLights)
						{
							getDynamicLights();
						}
					}
					progressBar.Increment();

					// Shaders / Feedback Connection.
					var feedback = Application.ActiveSceneRoot.FindChild(Constants.prefix + "_Feedback");
					if(feedback != null)
						connectFeedbackToShaders(feedback, selectedPasses);
					progressBar.Increment();

					// Ground Creation.
					if(Options.createGround)
						getGround();
					progressBar.Increment();

					// Final Gather Activation.
					if(Options.activateFinalGather)
						activateSceneFinalGather(selectedPasses);
					progressBar.Increment();

					// Linear Workflow Activation.
					if(Options.activateColorManagement)
						activateSceneColorManagement(selectedPasses);
					progressBar.Increment();

					progressBar.Visible = false;
				}

				SetCurrentLayer(layer);

				scriptEditorVerbose(true);
				autoInspectState(true);

				if(Options.updateScene)
					LogMessage(Constants.applicationName + " | '" + Constants.title + "' file update finished!");
				else
					LogMessage(Constants.applicationName + " | '" + Constants.title + "' file import finished!");

				if(Constants.globalPostProcessCommand)
				{
					LogMessage(Constants.applicationName + " | Executing overall postprocess Command!");
					Constants.globalPostProcessCommand()
				}

				if(Constants.localPostProcessCommand)
				{
					LogMessage(Constants.applicationName + " | Executing Template specific postprocess Command!");
					Constants.localPostProcessCommand()
				}
			}
			else
			{
				// Restoring Active Layer.
				SetCurrentLayer(layer);

				scriptEditorVerbose(true);
				autoInspectState(true);

				LogMessage(Constants.applicationName + " | No Pass selected, import canceled!");
			}
		}
	}
	catch (error)
	{
		scriptEditorVerbose(true);
		autoInspectState(true);

		LogMessage(Constants.applicationName + " | '" + Constants.title + "' file import failed!", siError);
		throw (error)
	}
}

function getPasses()
{
	var passes = new ActiveXObject("XSI.Collection");
	passes.SetAsText("Passes.List.*");

	var passesChooser_customProperty = Application.ActiveSceneRoot.AddCustomProperty("passesChooser_customProperty", false);

	var passParameters = []
	for(var i = 0; i < passes.count; i++)
	{
		passParameters[i] = passesChooser_customProperty.AddParameter3(passes.item(i).name, siBool, true);
	}

	var passesChooser_customProperty_layout = passesChooser_customProperty.PPGLayout;

	passesChooser_customProperty_layout.AddGroup("Scene Passes");
	for(var i = 0; i < passes.count; i++)
	{
		passesChooser_customProperty_layout.AddItem(passes.item(i).name);
	}
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.AddRow();
	passesChooser_customProperty_layout.AddGroup("", false, 100);
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.AddGroup("Options");
	var button = passesChooser_customProperty_layout.AddButton("ToggleAll", "Toggle All");
	button.SetAttribute(siUICX, 96)
	button = passesChooser_customProperty_layout.AddButton("UnToggleAll", "UnToggle All");
	button.SetAttribute(siUICX, 96)
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.EndRow();

	passesChooser_customProperty_layout.Logic = ToggleAll_OnClicked.toString() + UnToggleAll_OnClicked.toString();
	passesChooser_customProperty_layout.Language = "JScript";

	var returnValue = InspectObj(passesChooser_customProperty, "", Constants.applicationName + " Passes Chooser", siModal, false);

	if(!returnValue)
	{
		var selectedPasses = [];
		for(var i = 0; i < passParameters.length; i++)
		{
			if(passParameters[i].value == true)
			{
				selectedPasses[selectedPasses.length] = "Passes." + passParameters[i].name;
			}
		}
		deleteRequestedProperties("passesChooser_customProperty");
		return selectedPasses;
	}
	else
	{
		deleteRequestedProperties("passesChooser_customProperty");
		return null;
	}
}

function ToggleAll_OnClicked()
{
	// Starting At 1 To Ignore The PPG Name.
	for(var i = 1; i < PPG.Inspected.Item(0).Parameters.count; i++)
	{
		var boolean = "True";
		PPG.Inspected.Item(0).Parameters(i).value = boolean;
	}
}

function UnToggleAll_OnClicked()
{
	// Starting At 1 To Ignore The PPG Name.
	for(var i = 1; i < PPG.Inspected.Item(0).Parameters.count; i++)
	{
		var boolean = "False";
		PPG.Inspected.Item(0).Parameters(i).value = boolean;
	}
}

function hideSceneLights()
{
	var lights = Application.ActiveSceneRoot.FindChildren("", siLightPrimType);
	for(var i = 0; i < lights.count; i++)
	{
		lights(i).Properties("visibility").Parameters("viewvis").value = 0;
		lights(i).Properties("visibility").Parameters("rendvis").value = 0;
	}
}

function update_environmentDeletion()
{
	try
	{
		// Clip Shaders Deletion.
		if(Options.overrideTweaks)
		{
			if(!Options.createLighting)
				DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", Constants.prefix + "_Lighting_Clip", true));
			if(!Options.createReflection)
				DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", Constants.prefix + "_Reflection_Clip", true));
		}

		// Environment Shaders Deletion.
		if(Options.overrideTweaks)
		{
			if(!Options.createBackground)
				DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Background_Mib_Lookup_Spherical", true));
			if(!Options.createLighting)
			{
			}
			DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Lighting_Mib_Lookup_Spherical", true));
			if(!Options.createReflection)
				DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Reflection_Mib_Lookup_Spherical", true));
		}

		if(Options.overrideTweaks)
		{
			if(!Options.createSun)
				DeleteObj(getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_Sun", true));
		}

		if(Options.overrideTweaks)
		{
			if(!Options.createLights)
				DeleteObj(getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_DKL_", false));
		}

		if(Options.overrideTweaks)
		{
			if(!Options.createGround)
			{
				DeleteObj(getMatchingObjectsByClassID("{4C4F7500-51EF-11D0-854E-00A02417D029}", Constants.prefix + "_Ground_Material", false));
				DeleteObj(getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_Ground", true));
				DeleteObj(getMatchingObjectsByClassID("{479F2E10-3900-11D1-B0B3-00A024C79287}", Constants.prefix + "_Ground_Layer", true));
			}
		}
	}
	catch (error)
	{
	}
}

function environmentDeletion()
{
	try
	{
		// Transform Group Deletion.
		var controlsGroup = Application.ActiveSceneRoot.FindChild(Constants.prefix);
		if(controlsGroup != null)
		{
			Application.DeleteObj("B:" + Constants.prefix);
		}

		// Clips Deletion.
		DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", Constants.prefix, false));

		// Materials Deletion.
		DeleteObj(getMatchingObjectsByClassID("{4C4F7500-51EF-11D0-854E-00A02417D029}", Constants.prefix, false));

		// Shaders Deletion.
		DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix, false));

		// Environment Shader Stack Parameters Deletion.
		passesEnvironmentShaderStackParametersDeletion()

		// Display Layers Deletion.
		DeleteObj(getMatchingObjectsByClassID("{479F2E10-3900-11D1-B0B3-00A024C79287}", Constants.prefix, false));
	}
	catch (error)
	{
	}
}

function passesEnvironmentShaderStackParametersDeletion()
{
	var passes = new ActiveXObject("XSI.Collection");
	passes.SetAsText("Passes.List.*");
	var passParameters = [];
	for(var i = 0; i < passes.count; i++)
	{
		environmentShaderStack = passes.item(i).NestedObjects("EnvironmentShaderStack");
		for(var j = environmentShaderStack.Parameters.Count - 1; j >= 0; j--)
		{
			if(environmentShaderStack.Parameters.item(j).Sources.Count == 0)
				environmentShaderStack.Remove( j );
		}
	}
}

function getEnvironmentShaderBranch(pass, inputShader, imageSource, connectionPorts, name)
{
	var lookupSphericalShader = CreateShaderFromProgID("mentalray.mib_lookup_spherical.1.0", pass);
	SIConnectShaderToCnxPoint(imageSource, lookupSphericalShader.tex, false);

	var colorMathBasicShader = CreateShaderFromProgID("Softimage.sib_color_math_basic.1.0", pass);
	colorMathBasicShader.Parameters("op").value = 2;
	SIConnectShaderToCnxPoint(lookupSphericalShader, colorMathBasicShader + ".input1", false);

	var color_Math_ExponentShader = CreateShaderFromProgID("Softimage.sib_color_math_exponent.1.0", pass);
	SIConnectShaderToCnxPoint(colorMathBasicShader, color_Math_ExponentShader + ".input", false);

	var colorMathBasicGammaShader = CreateShaderFromProgID("Softimage.sib_color_math_basic.1.0", pass);
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		colorMathBasicGammaShader.Parameters("input1").Parameters(subComponents[i]).value = 1;
	colorMathBasicGammaShader.Parameters("op").value = 3;
	SIConnectShaderToCnxPoint(colorMathBasicGammaShader, color_Math_ExponentShader + ".factor", false);

	var colorSwitchShader = CreateShaderFromProgID("Softimage.sib_color_switch.1.0", pass);
	for(var i = 0; i < subComponents.length; i++)
		colorSwitchShader.Parameters("input2").Parameters(subComponents[i]).value = 0;
	SIConnectShaderToCnxPoint(color_Math_ExponentShader, colorSwitchShader + ".input1", false);

	for(var i = 0; i < connectionPorts.length; i++)
		SIConnectShaderToCnxPoint(colorSwitchShader, inputShader + "." + connectionPorts[i], false);

	colorMathBasicShader.Parameters("name").value = name + "_Color_Math_Basic";
	color_Math_ExponentShader.Parameters("name").value = name + "_Color_Math_Exponent";
	colorMathBasicGammaShader.Parameters("name").value = name + "_Gamma_Color_Math_Basic";
	colorSwitchShader.Parameters("name").value = name + "_Color_Switch";
	lookupSphericalShader.Parameters("name").value = name + "_Mib_Lookup_Spherical";
}

function update_environmentShaders(passes)
{
	var pass = passes[0];

	var raytype = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Raytype", true);
	raytype = raytype(0);

	var subComponents = ["red", "green", "blue"];

	if(raytype != null)
	{
		var ports = ["eye"];
		if(Options.createBackground)
		{
			var backgroundSource = getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", Constants.prefix + "_Background_Clip", true);
			if(backgroundSource != 0)
			{
				backgroundSource = backgroundSource(0);
				backgroundSource.Source.Parameters("FileName").Value = Data.backgroundFilePath;
			}
			else
			{
				backgroundSource = Application.CreateImageClip2(Data.backgroundFilePath, Constants.prefix + "_Background_Clip");
			}

			var backgroundLookupSphericalShader = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Background_Mib_Lookup_Spherical", true);
			if(backgroundLookupSphericalShader == 0)
				getEnvironmentShaderBranch(pass, raytype, backgroundSource, ports, Constants.prefix + "_Background");
		}
		else
		{
			if(Options.overrideTweaks)
			{
				for(var j = 0; j < subComponents.length; j++)
					raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
			}
		}

		ports = ["fg", "photon"];
		if(Options.createLighting)
		{
			var lightingSource = getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", Constants.prefix + "_Lighting_Clip", true);
			if(lightingSource != 0)
			{
				lightingSource = lightingSource(0);
				lightingSource.Source.Parameters("FileName").Value = Data.lightingFilePath;
			}
			else
			{
				lightingSource = Application.CreateImageClip2(Data.lightingFilePath, Constants.prefix + "_Lighting_Clip");
			}

			var lightingLookupSphericalShader = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Lighting_Mib_Lookup_Spherical", true);
			if(lightingLookupSphericalShader == 0)
				getEnvironmentShaderBranch(pass, raytype, lightingSource, ports, Constants.prefix + "_Lighting");
		}
		else
		{
			if(Options.overrideTweaks)
			{
				for(var i = 0; i < ports.length; i++)
				{
					for(var j = 0; j < subComponents.length; j++)
						raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
				}
			}
		}

		ports = ["reflection", "refraction"];
		if(Options.createReflection)
		{
			var reflectionSource = getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", Constants.prefix + "_Reflection_Clip", true);
			if(reflectionSource != 0)
			{
				reflectionSource = reflectionSource(0);
				reflectionSource.Source.Parameters("FileName").Value = Data.reflectionFilePath;
			}
			else
			{
				reflectionSource = Application.CreateImageClip2(Data.reflectionFilePath, Constants.prefix + "_Reflection_Clip");
			}

			var reflectionLookupSphericalShader = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", Constants.prefix + "_Reflection_Mib_Lookup_Spherical", true);
			if(reflectionLookupSphericalShader == 0)
				getEnvironmentShaderBranch(pass, raytype, reflectionSource, ports, Constants.prefix + "_Reflection");
		}
		else
		{
			if(Options.overrideTweaks)
			{
				for(var i = 0; i < ports.length; i++)
				{
					for(var j = 0; j < subComponents.length; j++)
						raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
				}
			}
		}

		// Connecting The Raytype Shader To Passes.
		for(var i = 0; i < passes.length; i++)
			SIConnectShaderToCnxPoint(raytype , passes[i] + ".EnvironmentShaderStack", false);
	}
	else
	{
		LogMessage(Constants.applicationName + " | No '" + Constants.prefix + "'_Raytype found, skipping environment related Shaders updates!", siWarning);
	}
}

function getEnvironmentShaders(passes)
{
	var pass = passes[0];

	var raytype = CreateShaderFromProgID("Softimage.sib_color_rayswitch.1.0", pass);
	var subComponents = ["red", "green", "blue"];
	raytype.Parameters("enable_fg").value = 1;
	for(var i = 0; i < subComponents.length; i++)
		raytype.Parameters("shadow").Parameters(subComponents[i]).value = 0;
	SIConnectShaderToCnxPoint(raytype , pass + ".EnvironmentShaderStack", false);

	var ports = ["eye", "refraction"];
	if(Options.createBackground)
	{
		var backgroundSource = Application.CreateImageClip2(Data.backgroundFilePath, Constants.prefix + "_Background_Clip");
		getEnvironmentShaderBranch(pass, raytype, backgroundSource, ports, Constants.prefix + "_Background");
	}
	else
	{
		for(var i = 0; i < ports.length; i++)
		{
			for(var j = 0; j < subComponents.length; j++)
				raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
		}
	}

	ports = ["fg", "photon"];
	if(Options.createLighting)
	{
		var lightingSource = Application.CreateImageClip2(Data.lightingFilePath, Constants.prefix + "_Lighting_Clip");
		getEnvironmentShaderBranch(pass, raytype, lightingSource, ports, Constants.prefix + "_Lighting");
	}
	else
	{
		for(var i = 0; i < ports.length; i++)
		{
			for(var j = 0; j < subComponents.length; j++)
				raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
		}
	}

	ports = ["reflection"];
	if(Options.createReflection)
	{
		var reflectionSource = Application.CreateImageClip2(Data.reflectionFilePath, Constants.prefix + "_Reflection_Clip");
		getEnvironmentShaderBranch(pass, raytype, reflectionSource, ports, Constants.prefix + "_Reflection");
	}
	else
	{
		for(var i = 0; i < ports.length; i++)
		{
			for(var j = 0; j < subComponents.length; j++)
				raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
		}
	}

	// Connecting The Raytype Shader To Others Passes.
	for(var i = 1; i < passes.length; i++)
		SIConnectShaderToCnxPoint(raytype , passes[i] + ".EnvironmentShaderStack", false);

	raytype.Parameters("name").value = Constants.prefix + "_Raytype";
}

function getControls(controlsGroup)
{
	var controls_customProperty = controlsGroup.AddCustomProperty(Constants.controlsTitle, false);

	// Render Togglers Parameters.
	controls_customProperty.AddParameter3("Background_Toggle", siBool, true);
	controls_customProperty.AddParameter3("Reflection_Toggle", siBool, true);
	controls_customProperty.AddParameter3("Lighting_Toggle", siBool, true);

	var slots = ["Background", "Reflection", "Lighting"];
	var components = ["Gamma", "Gain"];

	for(var i = 0; i < slots.length; i++)
	{
		for(var j = 0; j < components.length; j++)
			controls_customProperty.AddParameter3(slots[i] + "_" + components[j], siFloat, 1, 0, 10);
	}

	var controls_customProperty_layout = controls_customProperty.PPGLayout;

	controls_customProperty_layout.AddGroup("Render Togglers");
	controls_customProperty_layout.AddItem("Background_Toggle", "Background");
	controls_customProperty_layout.AddItem("Reflection_Toggle", "Reflection");
	controls_customProperty_layout.AddItem("Lighting_Toggle", "Lighting");
	controls_customProperty_layout.EndGroup();

	for(var i = 0; i < slots.length; i++)
	{
		controls_customProperty_layout.AddGroup(slots[i] + " Color Correction");
		for(var j = 0; j < components.length; j++)
			controls_customProperty_layout.AddItem(slots[i] + "_" + components[j], components[j]);
		controls_customProperty_layout.EndGroup();
	}
}

function getControlsGroup()
{
	var controlsGroup = Application.ActiveSceneRoot.FindChild(Constants.prefix);

	if(controlsGroup == null)
	{
		var null_ = ActiveSceneRoot.AddPrimitive("Null", "helperNull");
		var controlsGroup = Application.CreateTransformGroup(Constants.prefix, "B:" + null_);

		var locks = ["sclx", "scly", "sclz", "rotx", "roty", "rotz", "posx", "posy", "posz"];
		var globalKinematics = controlsGroup.Kinematics.Global.Parameters;
		for(var i = 0; i < locks.length; i++)
			globalKinematics(locks[i]).SetLock(siLockLevelManipulation);

		localKinematics = controlsGroup.Kinematics.Local.Parameters;
		for(var i = 0; i < locks.length; i++)
			localKinematics(locks[i]).SetLock(siLockLevelManipulation);

		DeleteObj(null_);

		getControls(controlsGroup)
	}

	return controlsGroup
}

function getFeedbackGeometry()
{
	var feedback = ActiveSceneRoot.AddGeometry("Sphere", "NurbsSurface", Constants.prefix + "_Feedback");
	feedback.properties("visibility").Parameters("rendvis").value = 0;

	if(!Options.displayFeedback)
		feedback.properties("visibility").Parameters("viewvis").value = 0;

	CreateProjection(feedback, siTxtUV, siTxtDefaultPlanarXY, null, Constants.prefix + "_Texture_Projection");

	var globalKinematics = feedback.Kinematics.Global.Parameters;
	globalKinematics("sclx").value = -globalKinematics("sclx").value;
	ResetTransform(feedback, siCtr, siSRT, siXYZ);
	globalKinematics("sclx").value = Options.feedbackRadius;
	globalKinematics("scly").value = Options.feedbackRadius;
	globalKinematics("sclz").value = Options.feedbackRadius;

	ApplyTopoOp("Inverse", feedback, 3, siImmediateOperation);

	var locks = ["rotx", "rotz", "posx", "posy", "posz"];
	for(var i = 0; i < locks.length; i++)
	{
		globalKinematics(locks[i]).SetLock(siLockLevelManipulation);
	}

	localKinematics = feedback.Kinematics.Local.Parameters;

	for(var i = 0; i < locks.length; i++)
	{
		localKinematics(locks[i]).SetLock(siLockLevelManipulation);
	}

	addToDisplayLayer(Constants.prefix + "_Feedback_Layer", feedback);

	return feedback;
}

function update_feedback()
{
	var feedback = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_Feedback", true);

	if(feedback == 0 && Options.overrideTweaks)
	{
		getFeedback();
	}
	else
	{
		feedback = feedback(0);
		if(feedback != null)
		{
			var globalKinematics = feedback.Kinematics.Global.Parameters;
			globalKinematics("roty").value = 0;

			//Not Working After The Feedback Has Been Frozen.
			//globalKinematics("sclx").value = -Options.feedbackRadius;
			//globalKinematics("scly").value = Options.feedbackRadius;
			//globalKinematics("sclz").value = Options.feedbackRadius;

			if(!Options.displayFeedback)
				feedback.properties("visibility").Parameters("viewvis").value = 0;
			else
				feedback.properties("visibility").Parameters("viewvis").value = 1;
		}
		else
		{
			LogMessage(Constants.applicationName + " | No Feedback found, skipping Feedback related updates!", siWarning);
		}
	}
}

function getFeedback()
{
	var controlsGroup = getControlsGroup();
	var feedback = getFeedbackGeometry();

	controlsGroup.AddChild(feedback);

	var feedbackMaterial = SICreateMaterial("Shaders/Material/Constant.Preset", Constants.prefix + "_Feedback_Material", null, null, false);

	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		feedbackMaterial.Parameters("Surface").NestedObjects(0).Parameters("transparency").Parameters(subComponents[i]).value = 0.5;

	AssignMaterial(feedbackMaterial + "," + feedback);
	if(Options.createBackground)
		SIConnectShaderToCnxPoint("Clips." + Constants.prefix + "_Background_Clip", feedbackMaterial + "." + Constants.prefix + "_Feedback_Material.color");

	return feedback
}

function update_lightsConstraints(light, scale, uCoordinate, vCoordinate)
{
	var globalKinematics = light.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = scale;

	var constraints = light.Kinematics.Constraints;

	for(var k = 0; k < constraints.Count; k++)
	{
		var constraint = constraints(k);
		if(constraint.Type == "surfcns")
		{
			// U -> V & V -> U Because Of The Invert Normal.
			constraint.Parameters("posu").Value = 0.5 + (0.5 - vCoordinate);
			constraint.Parameters("posv").Value = uCoordinate;
		}
		if(constraint.Type == "dircns")
		{
			constraint.Parameters("dirx").Value = 0;
			constraint.Parameters("dirz").Value = -1;
			constraint.Parameters("upvct_active").Value = 1;
		}
	}
}

function update_sun()
{
	var sun = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_Sun", true);

	if(sun == 0 && Options.overrideTweaks)
	{
		if(objectExists(Constants.prefix + "_Feedback"))
		{
			getSun();
		}
	}
	else
	{
		sun = sun(0);
		if(sun != null)
		{
			update_lightsConstraints(sun, Options.feedbackRadius / 15, Data.sunU, Data.sunV)
		}
		else
		{
			LogMessage(Constants.applicationName + " | No Sun found, skipping Sun related updates!", siWarning);
		}
	}
}

function update_dynamicsLights()
{
	var sceneDynamicLights = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_DKL_", false);

	if(sceneDynamicLights == 0 && Options.overrideTweaks)
	{
		if(objectExists(Constants.prefix + "_Feedback"))
		{
			getDynamicLights();
		}
	}
	else
	{
		for(var i = 0; i < sceneDynamicLights.Count; i++)
		{
			for(var j = 0; j < Data.dynamicLights.length; j++)
			{
				var regexPattern = new RegExp(Data.dynamicLights[j].name.replace(/\s/g, "_"));
				if(sceneDynamicLights(i).name.match(regexPattern))
				{
					update_lightsConstraints(sceneDynamicLights(i), Options.feedbackRadius / 15, Data.dynamicLights[j].uCoordinate, Data.dynamicLights[j].vCoordinate)
				}
			}
		}
	}
}

function getLight(parent, constraintParent, type, name, scale, physicalSun, intensity, color, uCoordinate, vCoordinate)
{
	switch(type)
	{
		case "Infinite":
			var primitiveType = "Infinite";
			break;
		case "Light Box":
			var primitiveType = "Light_Box";
			break;
		case "Point":
			var primitiveType = "Point";
			break;
		case "Spot":
			var primitiveType = "Spot";
			break;
	}

	var light = ActiveSceneRoot.AddPrimitive(primitiveType + ".Preset", name);
	parent.AddChild(light);

	var globalKinematics = light.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = scale;

	if(physicalSun && primitiveType == "Infinite")
	{
		physicalSunShader = CreateShaderFromProgID("mentalray.mia_physicalsun.1.0", light + ".light");
		SIConnectShaderToCnxPoint(physicalSunShader, light + ".light.LightShader", false);
		SIConnectShaderToCnxPoint(physicalSunShader, light + ".light.PhotonShader", false);
		physicalSunShader.Parameters("multiplier").value = intensity / 8;
		physicalSunShader.Parameters("y_is_up").value = true;

		DisconnectAndDeleteOrUnnestShaders(light + ".light.soft_light", light + ".light");
	}
	else
	{
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("intensity").value = intensity;
		var subComponents = ["red", "green", "blue"];
		for(var i = 0; i < subComponents.length; i++)
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("color").Parameters(subComponents[i]).value = color[i];
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("factor").value = 0;
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("shadow").value = true;
	}

	switch(type)
	{
		case "Distant":
			break;
		case "Point":
			break;
		case "Quad":
			var subComponents = ["SX", "SY", "SZ"];
			for(var i = 0; i < subComponents.length; i++)
				light.Primitives("light").Parameters("LightAreaXform" + subComponents[i]).value = 1;
			break;
		case "Spot":
			break;
	}

	var surfaceConstraint = ApplyCns("Surface", light, constraintParent);

	if(objectExists(Constants.prefix + "_Lights_Target"))
	{
		var lightTarget = Application.ActiveSceneRoot.FindChild(Constants.prefix + "_Lights_Target");
	}
	else
	{
		var lightTarget = ActiveSceneRoot.AddPrimitive("Null", Constants.prefix + "_Lights_Target");
	}

	parent.AddChild(lightTarget)

	var directionConstraint = ApplyCns("Direction", light, lightTarget);

	var constraints = light.Kinematics.Constraints;
	for(var i = 0; i < constraints.Count; i++)
	{
		var constraint = constraints(i);
		if(constraint.Type == "surfcns")
		{
			// U -> V & V -> U Because Of The Invert Normal.
			constraint.Parameters("posu").Value = 0.5 + (0.5 - vCoordinate);
			constraint.Parameters("posv").Value = uCoordinate;
		}
		if(constraint.Type == "dircns")
		{
			constraint.Parameters("dirx").Value = 0;
			constraint.Parameters("dirz").Value = -1;
		}
	}

	addToDisplayLayer(Constants.prefix + "_Lighting_Layer", lightTarget);

	addToDisplayLayer(Constants.prefix + "_Lighting_Layer", light);
}

function getSun()
{
	var controlsGroup = getControlsGroup();
	var feedback = Application.ActiveSceneRoot.FindChild(Constants.prefix + "_Feedback");

	getLight(controlsGroup, feedback, Options.sunLightType, Constants.prefix + "_Sun", Options.feedbackRadius / 10, Options.physicalSun, Data.sunMultiplier, Data.sunColor, Data.sunU, Data.sunV)
}

function getDynamicLights()
{
	var controlsGroup = getControlsGroup();
	var feedback = Application.ActiveSceneRoot.FindChild(Constants.prefix + "_Feedback");
	for(var i = 0; i < Data.dynamicLights.length; i ++)
		getLight(controlsGroup, feedback, Options.dynamicLightsType, Data.dynamicLights[i].name, Options.feedbackRadius / 15, false, Data.dynamicLights[i].multiplier, Data.dynamicLights[i].color, Data.dynamicLights[i].uCoordinate, Data.dynamicLights[i].vCoordinate);
}

function bridgeControlsAndShaders(pass, slot)
{
	AddExpr(pass + "." + Constants.prefix + "_" + slot + "_Color_Switch.switch", "1-(" + Constants.prefix + "." + Constants.controlsTitle + "." + slot + "_Toggle)", true);

	var components = ["red", "green", "blue"];
	for(var i = 0; i < components.length; i++)
	{
		AddExpr(pass + "." + Constants.prefix + "_" + slot + "_Color_Math_Basic.input2." + components[i], Constants.prefix + "." + Constants.controlsTitle + "." + slot + "_Gain", true);
		AddExpr(pass + "." + Constants.prefix + "_" + slot + "_Gamma_Color_Math_Basic.input2." + components[i], Constants.prefix + "." + Constants.controlsTitle + "." + slot + "_Gamma", true);
	}
}

function connectFeedbackToShaders(feedback, passes)
{
	var pass = passes[0];

	if(Options.createBackground)
	{
		SetExpr(pass + "." + Constants.prefix + "_Background_Mib_Lookup_Spherical.rotate", "(" + feedback + ".kine.global.roty / 2 )  * PI / 180 + ( 67.5 * PI / 180 )");
		bridgeControlsAndShaders(pass, "Background");
	}

	if(Options.createLighting)
	{
		SetExpr(pass + "." + Constants.prefix + "_Lighting_Mib_Lookup_Spherical.rotate", "(" + feedback + ".kine.global.roty / 2 )  * PI / 180 + ( 67.5 * PI / 180 )");
		bridgeControlsAndShaders(pass, "Lighting");
	}

	if(Options.createReflection)
	{
		SetExpr(pass + "." + Constants.prefix + "_Reflection_Mib_Lookup_Spherical.rotate", "(" + feedback + ".kine.global.roty / 2 )  * PI / 180 + ( 67.5 * PI / 180 )");
		bridgeControlsAndShaders(pass, "Reflection");
	}
}

function setRenderer()
{
	SetValue("Passes.RenderOptions.Renderer", "mental ray");
}

function activateSceneFinalGather(passes)
{
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		ActiveSceneRoot.Properties.Item("Ambient Lighting").Parameters("ambience").Parameters(subComponents[i]).value = 0;

	SetValue("Views.ViewA.RenderRegion.mentalray.FGEnable,Views.ViewB.RenderRegion.mentalray.FGEnable,Views.ViewC.RenderRegion.mentalray.FGEnable,Views.ViewD.RenderRegion.mentalray.FGEnable", Array(true, true, true, true));

	for(var i = 0; i < passes.length; i++)
	{
		var pass = Dictionary.GetObject(passes[i]);
		pass.Properties("mental ray").Parameters("FGEnable").value = true;
	}
}

function activateSceneColorManagement(passes)
{
	Application.Preferences.SetPreferenceValue("Display.color_management_source", 0);
	Application.Preferences.SetPreferenceValue("Display.color_management_render_region", true);
	Application.Preferences.SetPreferenceValue("Display.color_management_render_preview", true);
	Application.Preferences.SetPreferenceValue("Display.color_management_shader_balls", true);
	Application.Preferences.SetPreferenceValue("Display.color_management_ui_colors", true);

	for(var i = 0; i < passes.length; i++)
	{
		var pass = Dictionary.GetObject(passes[i]);
		pass.Parameters("UseDisplayGammaCorrection").value = true;
	}

	// Adjust Background Gamma Color Because Of The Color Management.
	if(Options.createBackground)
	{
		var Smart_IBL_Controls_Property = getRequestedPropertiesAsCollection(Constants.controlsTitle);
		Smart_IBL_Controls_Property.item(0).Background_Gamma.value = 1 / Constants.defaultGamma;
	}
}

function update_ground()
{
	var ground = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", Constants.prefix + "_Ground", true);
	if(ground == 0 && Options.overrideTweaks)
		getGround();
}

function getGround()
{
	var controlsGroup = getControlsGroup();

	var ground = ActiveSceneRoot.AddGeometry("Grid", "MeshSurface", Constants.prefix + "_Ground");
	controlsGroup.AddChild(ground)

	var globalKinematics = ground.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = (Options.feedbackRadius * Math.sqrt(2)) / 2;

	ResetTransform(ground, siCtr, siSRT, siXYZ);

	if(Options.shadowCatcher)
	{
		var groundMaterial = SICreateMaterial("Shaders/Material/mental images/mip_Matte_Shadow.Preset", Constants.prefix + "_Ground_Material", null, null, false);

		var constantShader = CreateShaderFromProgID("Softimage.material-constant.1.0", groundMaterial);

		var subComponents = ["red", "green", "blue"];
		for(var i = 0; i < subComponents.length; i++)
			constantShader.Parameters("transparency").Parameters(subComponents[i]).value = 1;

		constantShader.Parameters("Name").value = Constants.prefix + "_Ground_Constant";

		SIConnectShaderToCnxPoint(constantShader, groundMaterial + "." + Constants.prefix + "_Ground_Material.background");

		AssignMaterial(groundMaterial + "," + ground);
	}

	addToDisplayLayer(Constants.prefix + "_Ground_Layer", ground);
}

function objectExists(object)
{
	var seekedObject = Application.ActiveSceneRoot.FindChild(object);
	if(seekedObject != null)
		return true
	else
		return false
}

function commandExists(command)
{
	var commands = Application.Commands;

	var e = new Enumerator(commands)
	for( ; !e.atEnd(); e.moveNext() )
	{
		if(e.item() == command)
			return true
	}

	return false
}

function addToDisplayLayer(layerName, object)
{
	var sceneLayers = ActiveProject.ActiveScene.Layers;
	var layerExists = false;

	for(var i = 0; i < sceneLayers.Count; i++)
	{
		if(sceneLayers(i).name == layerName)
		{
			layerExists = true;
			break;
		}
	}

	if(!layerExists)
		CreateLayer(null, layerName, object);
	else
		MoveToLayer("Layers." + layerName, object);
}

function getSceneExtent()
{
	var meshes = getMatchingObjectsByClassID("{400CCE36-4400-11D0-BDDD-00A0241981E2}", ".*", false)
	var surfaces = getMatchingObjectsByClassID("{28DEC312-62B3-11D1-B79B-00A0243E3694}", ".*", false)
	var pointClouds = getMatchingObjectsByClassID("{2194FFE3-A0B2-4CAB-A3E8-FC8EDC9F159A}", ".*", false)

	var objects = extendCollection(meshes, surfaces);
	objects = extendCollection(objects, pointClouds);

	var parents = new ActiveXObject("XSI.Collection");
	for(var i = 0; i < objects.Count; i++)
		parents.add(objects(i).Parent);

	var sceneBoundingBox = GetBBox(parents);
	sceneBoundingBox = [sceneBoundingBox.value( "LowerBoundX" ), sceneBoundingBox.value( "LowerBoundY" ), sceneBoundingBox.value( "LowerBoundZ" ), sceneBoundingBox.value( "UpperBoundX" ), sceneBoundingBox.value( "UpperBoundY" ), sceneBoundingBox.value( "UpperBoundZ" )];
	var sceneExtent = 0
	for(var i = 0; i < sceneBoundingBox.length; i++)
		if( Math.abs(sceneBoundingBox[i]) > sceneExtent )
			sceneExtent = Math.abs(sceneBoundingBox[i]);
	return sceneExtent;
}

function truncFloatNumber(number, truncValue)
{
	if(truncValue != 0)
		return Math.round(number / truncValue) * truncValue;
	else
		return number;
}

function getExtendedFeedbackRadius()
{
	var sceneExtent = getSceneExtent();
	sceneExtent = (sceneExtent + (sceneExtent*50/100))/4;

	if(sceneExtent < Options.feedbackRadius)
		return Options.feedbackRadius;
	else
		return truncFloatNumber(sceneExtent,10);
}

function scriptEditorVerbose(verboseState)
{
	Application.Preferences.SetPreferenceValue("scripting.cmdlog", verboseState);
	Application.Preferences.SetPreferenceValue("scripting.msglog", verboseState);
	Application.Preferences.SetPreferenceValue("scripting.msglogverbose", verboseState);
}

function autoInspectState(autoInspectState)
{
	Application.Preferences.SetPreferenceValue("Interaction.autoinspect", autoInspectState);
}

function getRequestedPropertiesAsCollection(propertyType)
{
	var properties = getByClassIDAsCollection("{76332571-D242-11d0-B69C-00AA003B3EA6}");

	if(properties.count != 0)
	{
		var propertiesListAsStringArray = getCollectionAsStringArray(properties);

		var regexPattern = new RegExp(propertyType + "\\w*");

		var requestedProperties = new Array();

		for(var i = 0; i < propertiesListAsStringArray.length; i++)
		{
			var propertyFound = propertiesListAsStringArray[i].match(regexPattern);

			if(propertyFound)
				requestedProperties[requestedProperties.length] = propertiesListAsStringArray[i];
		}

		var requestedPropertiesAsCollection = new ActiveXObject("XSI.Collection");

		if(requestedProperties.length != 0)
			requestedPropertiesAsCollection = getStringArrayAsCollection(requestedProperties);

		return requestedPropertiesAsCollection;
	}
	else
	{
		return 0;
	}
}

function deleteRequestedProperties(propertyType)
{
	var requestedProperties = getRequestedPropertiesAsCollection(propertyType);

	for(var i = 0; i < requestedProperties.count; i++)
		DeleteObj(requestedProperties.item(i));
}

function getByClassIDAsCollection(currentClassID)
{
	var nodesByClassID = new ActiveXObject("XSI.Collection");

	nodesByClassID = FindObjects(null, currentClassID);

	return nodesByClassID;
}

function getCollectionAsStringArray(currentCollection)
{
	var collectionObjectsAsString = currentCollection.GetAsText();
	var collectionObjects = collectionObjectsAsString.split(",");

	return collectionObjects;
}

function getStringArrayAsCollection(currentStringArray)
{
	var stringArrayAsCollection = new ActiveXObject("XSI.Collection");
	stringArrayAsCollection.SetAsText(currentStringArray);

	return stringArrayAsCollection;
}

function extendCollection(initialCollection, extensionCollection)
{
	for(var i = 0; i < extensionCollection.Count; i++)
		initialCollection.Add(extensionCollection(i));
	return initialCollection;
}

function getMatchingObjectsByClassID(classID, pattern, matchExact)
{
	var objectsByClassID = new ActiveXObject("XSI.Collection");
	objectsByClassID = FindObjects(null, classID);
	matchingObjects = new ActiveXObject("XSI.Collection");
	for(var i = 0; i < objectsByClassID.Count; i++)
	{
		if(matchExact)
		{
			if(objectsByClassID(i).name == pattern)
				matchingObjects.Add(objectsByClassID(i));
		}
		else
		{
			if(objectsByClassID(i).name.match(pattern))
				matchingObjects.Add(objectsByClassID(i));
		}
	}
	return matchingObjects;
}