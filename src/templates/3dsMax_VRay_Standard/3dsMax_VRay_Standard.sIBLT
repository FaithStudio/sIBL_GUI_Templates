[Template]
Name = @Name | 3dsMax VRay Standard | String | Template Name
Path = @Path | | String | Template Path
HelpFile = @HelpFile | help/3dsMax_VRay_Standard_Template_Manual.html | String | Help File
Release = @Release | 1.1.2 | String | Template Release
Date = @Date | 11 March 2011 | String | Date
Author = @Author | Kel Solaar /Dschaga / JHaywood | String | Author
Email = @Email | thomas.mansencal@gmail.com | String | Email
Url = @Url | http://thomasmansencal.com/ | String | Url
Software = @Software | 3dsMax  | String | Software
Version = @Version | 2009 To 2011 | String | Version
Renderer = @Renderer | VRay| String | Renderer
OutputScript = @OutputScript | sIBL_3dsmax_Import.ms | String | Output Script
Comment = @Comment | This is 3dsmax 2009 To 2011 VRay Template. | String | Comment

[Ibl Set Attributes]
Background|BGfile = @BGfile
Reflection|REFfile = @REFfile
Enviroment|EVfile = @EVfile
Sun|SUNu = @SUNu
Sun|SUNv = @SUNv
Sun|SUNcolor = @SUNcolor
Sun|SUNmulti = @SUNmulti
Lights|DynamicLights = @dynamicLights

[Common Attributes]
sceneSetupPrefix = @sceneSetupPrefix | sIBL | String | Scene Setup Prefix
createBackground = @createBackground | 1 | Boolean | Create Background
createReflection = @createReflection | 1 | Boolean | Create Reflection
createLighting = @createLighting | 1 | Boolean | Create Lighting
createSun = @createSun | 1 | Boolean | Create Sun
createLights = @createLights | 1 | Boolean | Create Dynamic Lights

[Additional Attributes]
displayFeedback = @displayFeedback | 1 | Boolean | Display Feedback
sunLightType = @sunLightType | VRaySun;Direct;Spot;Omni;Photometric;VRayLight;VRayIES | Enum | Sun Light Type
dynamicLightsType = @dynamicLightsType | Direct;Spot;Omni;Photometric;VRaySun;VRayLight;VRayIES | Enum | Dynamic Lights Type
hideLights = @hideLights | 1 | Boolean | Hide Lights
createGround = @createGround | 1 | Boolean | Create Ground
shadowCatcher = @shadowCatcher | 1 | Boolean | Ground Shadow Catcher
activateLinearWorkflow = @activateLinearWorkflow | 1 | Boolean | Activate Linear Workflow

[Remote Connection]
ConnectionType = @ConnectionType | Win32 | String
TargetApplication = @TargetApplication | MAX.Application | String
ExecutionCommand = @ExecutionCommand | fileIn ("$loaderScriptPath") | String

[Script]
/*
@OutputScript - @Release for @Software @Version
Author: @Author
EMail: @Email
Homepage: @Url
Template path: @Path
Template last modified: @Date
sIBL_GUI
*/

struct sIBL_data (backgroundFilePath, reflectionFilePath, lightingFilePath, sunU, sunV, sunColor, sunMultiplier, dynamicLights)
struct sIBL_options (createBackground, createLighting, createReflection,  createSun, createLights, displayFeedback, feedbackRadius, hideLights, sunLightType, dynamicLightsType, createGround, shadowCatcher, activateLinearWorkflow)
struct sIBL_sceneNodes (dataGroup,  lightsGroup, feedback)

global sIBL_DATAS =  sIBL_data backgroundFilePath:"@BGfile" reflectionFilePath:"@REFfile" lightingFilePath:"@EVfile" sunU:@SUNu sunV:@SUNv sunColor:"@SUNcolor" sunMultiplier:@SUNmulti dynamicLights:"@dynamicLights"
global sIBL_OPTIONS = sIBL_options createBackground:@createBackground createReflection:@createReflection createLighting:@createLighting createSun:@createSun createLights:@createLights displayFeedback:@displayFeedback feedbackRadius:1000 sunLightType:"@sunLightType" dynamicLightsType:"@dynamicLightsType" hideLights:@hideLights createGround:@createGround shadowCatcher:@shadowCatcher activateLinearWorkflow:@activateLinearWorkflow
global sIBL_SCENE_NODES = sIBL_sceneNodes()

fn sIBL_3dsmax_VRay_getSceneExtent =
(
	sceneExtent = 0
	for object_ in Geometry do
	(
		bBox = nodeGetBoundingBox object_ (Matrix3 1)
		for i = 1 to bBox.count  do
		(
			toArray = #(abs(bBox[i].x), abs(bBox[i].y), abs(bBox[i].z))
			if amax(toArray) > sceneExtent then sceneExtent = amax(toArray)
		)
	)

	return sceneExtent
)

fn sIBL_3dsmax_VRay_truncFloatNumber number truncValue =
(
	if truncValue != 0 then
		return floor(number / truncValue) * truncValue
	else
		return number
)

fn sIBL_3dsmax_VRay_getExtendedFeedbackRadius feedbackRadius =
(
	sceneExtent = sIBL_3dsmax_VRay_getSceneExtent()
	sceneExtent = sceneExtent + (sceneExtent*50/100)

	if sceneExtent < feedbackRadius then
		return feedbackRadius
	else
		return sIBL_3dsmax_VRay_truncFloatNumber sceneExtent 10
)

fn sIBL_3dsmax_VRay_getDefaultControllers currentNode =
(
	currentNode.Transform.controller = prs ()
	currentNode.rotation.controller = Euler_XYZ ()
	currentNode.scale.controller = bezier_scale ()
)

fn sIBL_3dsmax_VRay_environmentDeletion =
(
	-- sIBL Nodes Deletion.
	delete $sIBL_*

	-- sIBL Environment Map Deletion.
	environmentMap = undefined

	freeSceneBitmaps()
)

fn sIBL_3dsmax_VRay_activateVRay =
(
	if(IsKindOf renderers.current vray == False ) then
		renderers.current = vray()

	renderers.current.gi_on = True
)

fn sIBL_3dsmax_VRay_hideLights =
(
	hide lights
)

fn sIBL_3dsmax_VRay_getSIBLGroup =
(
	local sIBL_Point = Point name:"sIBL_Point" centermarker:off axistripod:off cross:off Box:off
	sIBL_SCENE_NODES.dataGroup = group sIBL_Point name:"sIBL_Data"
)

fn sIBL_3dsmax_VRay_getFeedback feedbackRadius createBackground texturePath =
(
	local feedbackSphere = Sphere radius:feedbackRadius segs:32 mapcoords:on backfacecull:on renderable:off

	sIBL_3dsmax_VRay_getDefaultControllers feedbackSphere

	local normalModifier_ = Normalmodifier()
	normalModifier_.flip = True
	addModifier feedbackSphere normalModifier_
	collapseStack feedbackSphere

	feedbackSphere.backfacecull = on
	feedbackSphere.renderable = False

	if(createBackground == 1) then
	(
		local feedbackShader = StandardMaterial name:"sIBL_FeedbackShader"
		feedbackShader.selfIllumAmount = 100
		feedbackShader.diffuse = color 255 255 255
		feedbackShader.ambient = feedbackShader.diffuse

		feedBackTexture = Bitmaptexture fileName:texturePath
		feedBackTexture.coordinates.u_tiling = -1
		feedbackShader.diffuseMap =  feedBackTexture
		feedbackShader.selfillumMap =  feedBackTexture

		feedbackSphere.material = feedbackShader
		showTextureMap feedbackShader True
	)

	feedbackSphere.parent = sIBL_SCENE_NODES.dataGroup
	setTransformLockFlags feedbackSphere #{1,2,3,4,5}

	feedbackSphere.name = "sIBL_Feedback"
	sIBL_SCENE_NODES.feedback = feedbackSphere
)

fn sIBL_3dsmax_VRay_getLightsGroup =
(
	local sIBL_Point = Point name:"sIBL_Lights_Point" centermarker:off axistripod:off cross:off Box:off
	sIBL_SCENE_NODES.lightsGroup = group sIBL_Point name:"sIBL_Lights"

	sIBL_3dsmax_VRay_getDefaultControllers sIBL_SCENE_NODES.lightsGroup

	sIBL_SCENE_NODES.lightsGroup.parent = sIBL_SCENE_NODES.dataGroup
)

fn sIBL_3dsmax_VRay_getLight lightType lightName lightColor intensity lightDistance uCoordinate vCoordinate =
(
	if(sIBL_SCENE_NODES.lightsGroup == undefined) then
		sIBL_3dsmax_VRay_getLightsGroup()

	lightColorTokens = filterstring lightColor ","

	uCoordinate += 0.75
	projectedRadius = cos((0.5 - vCoordinate) * 180)

	local xPos = lightDistance * ((cos(uCoordinate * 360)) * projectedRadius)
	local yPos = lightDistance * ((sin(uCoordinate * 360)) * projectedRadius) * -1
	local zPos = lightDistance * (sin((0.5 - vCoordinate) * 180))

	local lightTarget = TargetObject transform:(matrix3 [1,0,0] [0,1,0] [0,0,1] [0,0,0])
	lightTarget.parent = sIBL_SCENE_NODES.lightsGroup

	local lightColor = color (lightColorTokens[1] as float) (lightColorTokens[2] as float) (lightColorTokens[3] as float)
	local lightFalloff = lightDistance + 5

	if(lightType == "Direct") then
	(
		local light = TargetDirectionalLight castShadows:on hotspot:lightDistance falloff:lightFalloff
	)
	else if(lightType == "Spot") then
	(
		local light = TargetSpot castShadows:on hotspot:lightDistance falloff:lightFalloff
	)
	else if(lightType == "Omni") then
	(
		local light = OmniLight castShadows:on
	)
	else if(lightType == "Photometric") then
	(
		local light = Target_Light rgbFilter:lightColor castShadows:on
		light.intensity = 1.0 * (intensity as float)  * (lightDistance * lightDistance)
	)
	else if(lightType == "VRaySun") then
	(
		local light = VRaySun()
		light.intensity_multiplier = intensity * 0.0215
	)
	else if(lightType == "VRayLight") then
	(
		local light = VRayLight()
		light.color = lightColor
		light.normalizeColor = 1
		light.multiplier = 2.85 * (intensity as float) * (lightDistance * lightDistance)
		light.size0 = 1 *  (lightDistance / 100)
		light.size1 = 1 *  (lightDistance / 100)
		light.subdivs = 24
	)
	else if(lightType == "VRayIES") then
	(
		local light = VRayIES()
		light.color = lightColor
		light.power = 11.5 * (intensity as float) * (lightDistance * lightDistance)
		light.shape_subdivs = 24
	)

	if(lightType == "Direct" or lightType == "Spot" or lightType == "Omni" or lightType == "Photometric") then
	(
		light.rgb = lightColor
		light.multiplier = (intensity as float)
		light.shadowGenerator = VRayShadow()
	)

	light.pos = [(xPos as float),  (yPos as float), (zPos as float)]
	light.target = lightTarget

	light.parent = sIBL_SCENE_NODES.lightsGroup

	lightTarget.name = lightName + "_Target"
	light.name = lightName
)

fn sIBL_3dsmax_VRay_createSun sunLightType sunColor sunMultiplier lightDistance sunU sunV =
(
	sIBL_3dsmax_VRay_getLight sunLightType "sIBL_Sun" sunColor sunMultiplier lightDistance sunU sunV
)

fn sIBL_3dsmax_VRay_createDynamicLights dynamicLightsType dynamicLights lightDistance =
(
	local dynamicLightsTokens = filterString dynamicLights "|"

	for i = 1 to dynamicLightsTokens.count by 8 do
	(
		local lightName = "sIBL_" + substituteString dynamicLightsTokens[i+1] " " "_"
		local lightColor = dynamicLightsTokens[i+2] + "," + dynamicLightsTokens[i+3] + "," + dynamicLightsTokens[i+4]
		local intensity = dynamicLightsTokens[i+5] as float
		local uCoordinate = dynamicLightsTokens[i+6] as float
		local vCoordinate = dynamicLightsTokens[i+7] as float

		sIBL_3dsmax_VRay_getLight dynamicLightsType lightName lightColor intensity lightDistance uCoordinate vCoordinate
	)
)

fn sIBL_3dsmax_VRay_getEnvironmentBranch branchName filePath =
(
	local texture = VRayHDRI()
	texture.hdriMapName = filePath
	texture.horizontalRotation = 90
	texture.horizontalFlip = True
	texture.maptype = 2

	texture.name = branchName + "_VRayHDRI"

	return texture
)

fn sIBL_3dsmax_VRay_getClassicEnvironmentBranch branchName filePath =
(
	local texture = Bitmaptexture()
	texture.filename = filePath
	texture.coordinates.UVW_Type = 0
	texture.coordinates.mappingtype = 1
	texture.coordinates.mapping = 0
	texture.coordinates.U_Tile = True
	texture.coordinates.U_Tiling = -1.0
	texture.coordinates.U_Offset = 0

	local colorCorrection_ =  ColorCorrection()
	colorCorrection_.map = texture

	texture.name = branchName + "_BitmapTexture"
	colorCorrection_.name = branchName + "_ColorCorrection"

	return colorCorrection_
)

fn sIBL_3dsmax_VRay_setEnvironment createBackground createLighting createReflection backgroundFilePath lightingFilePath reflectionFilePath =
(
	if(createBackground == 1) then
	(
		local backgroundBranch = sIBL_3dsmax_VRay_getClassicEnvironmentBranch "sIBL_Background" backgroundFilePath
		environmentMap = backgroundBranch
		-- Fact: 3dsMax 2010 Fails To Update Correctly The Coordinates Mapping Type Until Connected To The EnvironmentMap Slot.
		environmentMap.map.coordinates.mapping = 0
	)

	if(createLighting == 1) then
	(
		local lightingBranch = sIBL_3dsmax_VRay_getEnvironmentBranch "sIBL_Lighting" lightingFilePath
		renderers.current.environment_gi_on = True
		renderers.current.environment_gi_map = lightingBranch
	)

	if(createReflection == 1) then
	(
		local reflectionBranch = sIBL_3dsmax_VRay_getEnvironmentBranch "sIBL_Reflection" reflectionFilePath
		renderers.current.environment_rr_on = True
		renderers.current.environment_rr_map = reflectionBranch

		local refractionBranch = sIBL_3dsmax_VRay_getEnvironmentBranch "sIBL_Refraction" reflectionFilePath
		renderers.current.environment_refract_on = True
		renderers.current.environment_refract_map = refractionBranch
	)
)

fn sIBL_3dsmax_VRay_connectFeedbackToSIBLShaders createBackground createLighting createReflection =
(
	if(createBackground == 1) then
	(
		paramWire.connect sIBL_SCENE_NODES.feedback.rotation.controller[#Z_Rotation] environmentMap.map.coordinates[#U_Offset] "(Z_Rotation-(pi*2))*2/pi/4"
	)

	if(createLighting == 1) then
	(
		paramWire.connect sIBL_SCENE_NODES.feedback.rotation.controller[#Z_Rotation] renderers.current.environment_gi_map[#horizontalRotation] "-Z_Rotation+(pi/2)"
	)

	if(createReflection == 1) then
	(
		paramWire.connect sIBL_SCENE_NODES.feedback.rotation.controller[#Z_Rotation] renderers.current.environment_rr_map[#horizontalRotation] "-Z_Rotation+(pi/2)"
		paramWire.connect sIBL_SCENE_NODES.feedback.rotation.controller[#Z_Rotation] renderers.current.environment_refract_map[#horizontalRotation] "-Z_Rotation+(pi/2)"
	)
)

fn sIBL_3dsmax_VRay_connectFeedbackToLights =
(
	if(sIBL_SCENE_NODES.lightsGroup != undefined) then
	(
		paramWire.connect sIBL_SCENE_NODES.feedback.rotation.controller[#Z_Rotation] sIBL_SCENE_NODES.lightsGroup.rotation.controller[#Z_Rotation] "Z_Rotation"
		paramWire.connect sIBL_SCENE_NODES.feedback.transform.controller[#Scale] sIBL_SCENE_NODES.lightsGroup.transform.controller[#Scale] "Scale"
	)
)

fn sIBL_3dsmax_VRay_createGround currentScale shadowCatcher =
(
	local currentScale = currentScale * (sqrt 2)
	local currentPlane = plane typeinCreationMethod:1 length:currentScale width:currentScale
	currentPlane.backfacecull = on
	currentPlane.parent = sIBL_SCENE_NODES.dataGroup

	if(shadowCatcher == 1) then
	(
		local groundShader = VRayMtlWrapper name:"sIBL_GroundShader"
		groundShader.baseMtl = VRayMtl  name:"sIBL_GroundShader_Base"
		groundShader.matteSurface = on
		groundShader.matte_shadows = on
		groundShader.alphaContribution = -1
		groundShader.matte_shadowsAffectAlpha = on

		for property in #("VRay_GI_VisibleToGI", "VRay_GI_VisibleToReflections", "VRay_GI_VisibleToRefractions") do
			setUserProp currentPlane property false
	)
	else
	(
		local groundShader = VRayMtl name:"sIBL_GroundShader"
	)

	currentPlane.material = groundShader

	currentPlane.name =  "sIBL_Ground"
)

fn sIBL_3dsmax_VRay_activateLinearWorkflow createBackground =
(
	renderers.current.colorMapping_gamma = 2.2
	if(createBackground == 1) then
	(
		environmentMap.lightnessMode = 1
		environmentMap.gammaRGB = 1/2.2
	)
)

fn sIBL_3dsmax_VRay_setup  =
(
	if(vray != undefined) then
	(
		if(sIBL_3dsmax_preProcessCallback != undefined) then
		(
			print "sIBL_GUI | Executing overall preprocess Callback!"
			sIBL_3dsmax_preProcessCallback()
		)

		if(sIBL_3dsmax_VRay_preProcessCallback != undefined) then
		(
			print "sIBL_GUI | Executing Template specific preprocess Callback!"
			sIBL_3dsmax_VRay_preProcessCallback()
		)

		print "sIBL_GUI | Starting Ibl file import!"

		sIBL_3dsmax_VRay_environmentDeletion()

		sIBL_OPTIONS.feedbackRadius = sIBL_3dsmax_VRay_getExtendedFeedbackRadius sIBL_OPTIONS.feedbackRadius

		sIBL_3dsmax_VRay_activateVRay()

		if(sIBL_OPTIONS.hideLights == 1) then
			sIBL_3dsmax_VRay_hideLights()

		sIBL_3dsmax_VRay_getSIBLGroup()

		if(sIBL_OPTIONS.displayFeedback == 1) then
			sIBL_3dsmax_VRay_getFeedback sIBL_OPTIONS.feedbackRadius sIBL_OPTIONS.createBackground sIBL_DATAS.backgroundFilePath

		sIBL_3dsmax_VRay_setEnvironment sIBL_OPTIONS.createBackground sIBL_OPTIONS.createLighting sIBL_OPTIONS.createReflection sIBL_DATAS.backgroundFilePath sIBL_DATAS.lightingFilePath sIBL_DATAS.reflectionFilePath

		if(sIBL_OPTIONS.displayFeedback == 1) then
			sIBL_3dsmax_VRay_connectFeedbackToSIBLShaders  sIBL_OPTIONS.createBackground sIBL_OPTIONS.createLighting sIBL_OPTIONS.createReflection

		if(sIBL_OPTIONS.createSun == 1 and sIBL_DATAS.sunU != -1 and sIBL_DATAS.sunV != -1) then
			sIBL_3dsmax_VRay_createSun sIBL_OPTIONS.sunLightType sIBL_DATAS.sunColor sIBL_DATAS.sunMultiplier sIBL_OPTIONS.feedbackRadius sIBL_DATAS.sunU sIBL_DATAS.sunV

		if(sIBL_OPTIONS.createLights == 1 and sIBL_DATAS.dynamicLights != "-1") then
			sIBL_3dsmax_VRay_createDynamicLights sIBL_OPTIONS.dynamicLightsType sIBL_DATAS.dynamicLights sIBL_OPTIONS.feedbackRadius

		if(sIBL_OPTIONS.displayFeedback == 1) then
			sIBL_3dsmax_VRay_connectFeedbackToLights()

		if(sIBL_OPTIONS.createGround == 1) then
			sIBL_3dsmax_VRay_createGround sIBL_OPTIONS.feedbackRadius sIBL_OPTIONS.shadowCatcher

		if(sIBL_OPTIONS.activateLinearWorkflow == 1) then
			sIBL_3dsmax_VRay_activateLinearWorkflow sIBL_OPTIONS.createBackground

		print "sIBL_GUI | Ibl file import finished!"

		if(sIBL_3dsmax_postProcessCallback != undefined) then
		(
			print "sIBL_GUI | Executing overall postprocess Callback!"
			sIBL_3dsmax_postProcessCallback()
		)

		if(sIBL_3dsmax_VRay_postProcessCallback != undefined) then
		(
			print "sIBL_GUI | Executing Template specific postprocess Callback!"
			sIBL_3dsmax_VRay_postProcessCallback()
		)
	)
	else
		messageBox "sIBL_GUI | VRay Renderer Is Not Available!" title:"sIBL_GUI Error"
)

(
	local sIBL_proceedSetup = 1
	if(sIBL_DATAS.backgroundFilePath == "-1" or sIBL_DATAS.reflectionFilePath == "-1" or sIBL_DATAS.lightingFilePath == "-1") then
	(
		if not queryBox "sIBL_GUI | Non Template compatible Ibl Set provided: Unpredictable results may occur! Would you like to proceed anyway?" beep:false then
			sIBL_proceedSetup = 0
	)

	if(sIBL_proceedSetup == 1)	then
		sIBL_3dsmax_VRay_setup()
	else
		print "sIBL_GUI | Ibl file import aborted!"
)