[Template]
Name = @Name | Softimage Arnold Dome Light | String | Template Name
Path = @Path | | String | Template Path
HelpFile = @HelpFile | help/Softimage_Arnold_Dome_Light_Template_Manual.html | String | Help File
Release = @Release | 0.9.8 | String | Template Release
Date = @Date | 11 March 2011 | String | Date
Author = @Author | Kel Solaar | String | Author
Email = @Email | thomas.mansencal@gmail.com | String | Email
Url = @Url | http://www.thomasmansencal.com/ | String | Url
Software = @Software | Softimage | String | Software
Version = @Version | 2011 | String | Version
Renderer = @Renderer | Arnold | String | Renderer
OutputScript = @OutputScript | sIBL_XSI_Import.js | String | Output Script
Comment = @Comment | This is Softimage 2011 Arnold Dome Light Template. | String | Comment

[Ibl Set Attributes]
Background|BGfile = @BGfile
Reflection|REFfile = @REFfile
Reflection|REFmulti = @REFmulti
Reflection|REFgamma = @REFgamma
Enviroment|EVfile = @EVfile
Enviroment|EVmulti = @EVmulti
Enviroment|EVgamma = @EVgamma
Sun|SUNu = @SUNu
Sun|SUNv = @SUNv
Sun|SUNcolor = @SUNcolor
Sun|SUNmulti = @SUNmulti
Lights|DynamicLights = @dynamicLights
Header|Height = @Height
Header|North = @North

[Common Attributes]
createBackground = @createBackground | 1 | Boolean | Create Background
createReflection = @createReflection | 1 | Boolean | Create Reflection
createLighting = @createLighting | 1 | Boolean | Create Lighting
createSun = @createSun | 1 | Boolean | Create Sun
createLights = @createLights | 1 | Boolean | Create Dynamic Lights

[Additional Attributes]
showPassesDialog = @showPassesDialog | 0 | Boolean | Passes Selection Dialog
displayFeedback = @displayFeedback | 1 | Boolean | Display Feedback
sunLightType = @sunLightType | Distant;Quad;Spot;Point | Enum | Sun Light Type
dynamicLightsType = @dynamicLightsType | Distant;Quad;Spot;Point | Enum | Dynamic Lights Type
hideLights = @hideLights | 1 | Boolean | Hide Lights
createGround = @createGround | 1 | Boolean | Create Ground
useDualSkydomeSetup = @useDualSkydomeSetup | 1 | Boolean | Use Dual Skydome Setup
useReflectionForLighting = @useReflectionForLighting | 0 | Boolean | Use Reflection Image For Lighting
activateLinearWorkflow = @activateLinearWorkflow | 1 | Boolean | Activate Linear Workflow
useArnoldGammaCorrection = @useArnoldGammaCorrection | 1 | Boolean | Use Arnold Gamma Correction

[Remote Connection]
ConnectionType = @ConnectionType | Socket | String | Connection Type
ExecutionCommand = @ExecutionCommand | $loaderScriptPath | String | ExecutionCommand
DefaultAddress = @DefaultAddress | 127.0.0.1 | Integer | Default Address
DefaultPort = @DefaultPort | 12288 | Integer | Default Port

[Script]
// @OutputScript - @Release for @Software @Version
// Author: @Author
// EMail: @Email
// Homepage: @Url
// Template path: @Path
// Template last modified: @Date
// sIBL_GUI
function __constants()
{
	this.applicationName = "sIBL_GUI";
	this.prefix = "@sceneSetupPrefix";
	this.package = "@Software".replace(" ", "_");
	this.renderer = "@Renderer".replace(" ", "_");
	this.packagePrefix = this.prefix + this.package;
	this.packageRendererPrefix = this.prefix + this.package + this.renderer;
	this.title = "Smart IBL";
	this.controlsTitle = "[ " + this.title + " Controls ]";
	this.defaultGamma = 2.2;
}
var Constants = new __constants();

function __data()
{
	this.backgroundFilePath = "@BGfile";
	this.reflectionFilePath = "@REFfile";
	this.reflectionMultiplier = @REFmulti;
	this.reflectionGamma = @REFgamma;
	this.lightingFilePath = "@EVfile";
	this.lightingMultiplier = @EVmulti;
	this.lightingGamma = @EVgamma;
	this.sunU = @SUNu;
	this.sunV = @SUNv;
	this.sunColor = [@SUNcolor];
	this.sunMultiplier = @SUNmulti;
	this.dynamicLights = "@dynamicLights";
	this.height = @Height;
	this.north = @North;
}
var Data = new __data();

function __options()
{
	this.createBackground = @createBackground;
	this.createReflection = @createReflection;
	this.createLighting = @createLighting;
	this.createSun = @createSun;
	this.createLights = @createLights;
	this.showPassesDialog = @showPassesDialog;
	this.displayFeedback = @displayFeedback;
	this.feedbackRadius = 100;
	this.sunLightType = "@sunLightType";
	this.dynamicLightsType = "@dynamicLightsType";
	this.hideLights = @hideLights;
	this.createGround = @createGround;
	this.useDualSkydomeSetup = @useDualSkydomeSetup;
	this.useReflectionForLighting = @useReflectionForLighting;
	this.activateLinearWorkflow = @activateLinearWorkflow;
	this.useArnoldGammaCorrection = @useArnoldGammaCorrection;
}
var Options = new __options();

var proceedSetup = true;
if(backgroundFilePath == "-1" || reflectionFilePath == "-1" || lightingFilePath == "-1")
{
	var result = XSIUIToolkit.Msgbox( "sIBL_GUI | Non Template compatible Ibl Set provided: Unpredictable results may occur! Would you like to proceed anyway?", siMsgYesNo | siMsgQuestion, "sIBL_GUI " ) ;
	if (result == siMsgNo )
		proceedSetup = false;
}
if(proceedSetup)
	setup(backgroundFilePath,
						reflectionFilePath,
						reflectionMultiplier,
						reflectionGamma,
						lightingFilePath,
						lightingMultiplier,
						lightingGamma,
						sunU,
						sunV,
						sunColor,
						sunMultiplier,
						dynamicLights,
						height,
						north,
						createBackground,
						createReflection,
						createLighting,
						createSun,
						createLights,
						showPassesDialog,
						displayFeedback,
						feedbackRadius,
						sunLightType,
						dynamicLightsType,
						hideLights,
						createGround,
						useDualSkydomeSetup,
						useReflectionForLighting,
						activateLinearWorkflow,
						useArnoldGammaCorrection);
else
	LogMessage("sIBL_GUI | Ibl file import aborted!");

function setup(backgroundFilePath,
							reflectionFilePath,
							reflectionMultiplier,
							reflectionGamma,
							lightingFilePath,
							lightingMultiplier,
							lightingGamma,
							sunU,
							sunV,
							sunColor,
							sunMultiplier,
							dynamicLights,
							height,
							north,
							createBackground,
							createReflection,
							createLighting,
							createSun,
							createLights,
							showPassesDialog,
							displayFeedback,
							feedbackRadius,
							sunLightType,
							dynamicLightsType,
							hideLights,
							createGround,
							useDualSkydomeSetup,
							useReflectionForLighting,
							activateLinearWorkflow,
							useArnoldGammaCorrection)
{
	try
	{
		if(arnoldRendererExists())
		{
			if(commandExists("sIBL_XSI_preProcessCommand"))
			{
				LogMessage("sIBL_GUI | Executing overall preprocess Command!");
				sIBL_XSI_preProcessCommand();
			}

			if(commandExists("preProcessCommand"))
			{
				LogMessage("sIBL_GUI | Executing Template specific preprocess Command!");
				preProcessCommand();
			}

			// Storing Active Layer.
			var layer = ActiveProject.ActiveScene.ActiveLayer;

			var selectedPasses = [];

			if(showPassesDialog)
				selectedPasses = getPasses();
			else
				selectedPasses[0] = GetCurrentPass();

			if(selectedPasses != null)
			{
				if(selectedPasses.length != 0)
				{
					LogMessage("sIBL_GUI | Starting Ibl file import!");

					scriptEditorVerbose(false);
					autoInspectState(false);

					var progressBar = XSIUIToolkit.ProgressBar;
					progressBar.Maximum = 100;
					progressBar.CancelEnabled = false;

					progressBar.Caption = "sIBL_GUI | Importing Ibl file!";

					progressBar.Step = 10;
					progressBar.Visible = true;

					// Defines Sun And Dynamic Lights Existence From Ibl file.
					if(sunU != -1 && sunV != -1)
						var sunExists = true;
					else
						var sunExists = false;

					if(dynamicLights != -1)
						var dynamicLightsExists = true
					else
						var dynamicLightsExists = false

					// Scene Cleanup.
					environmentDeletion();
					progressBar.Increment();

					// Defines sIBL_Feedback Radius From Scene Extent.
					feedbackRadius = getExtendedFeedbackRadius(feedbackRadius);

					// Activating Renderer.
					setRenderer();
					progressBar.Increment();

					// Lights Hide.
					if(hideLights)
						hideSceneLights();
					progressBar.Increment();

					// Environment Shaders Creation.
					getEnvironment(createBackground, createLighting, createReflection, backgroundFilePath, lightingFilePath, reflectionFilePath, useDualSkydomeSetup, useReflectionForLighting, selectedPasses);
					progressBar.Increment();

					// Feedback Creation.
					getFeedback(feedbackRadius, createBackground, displayFeedback);
					progressBar.Increment();

					// Sun Creation
					if(sunExists)
					{
						if(createSun)
						{
							if(objectExists("sIBL_Feedback"))
							{
								getSun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius);
							}
						}
					}
					progressBar.Increment();

					// Dynamic Lights Creation.
					if(dynamicLightsExists)
					{
						if(createLights)
						{
							getDynamicLights(dynamicLightsType, dynamicLights, feedbackRadius);
						}
					}
					progressBar.Increment();

					// Shaders / Feedback Connection.
					var feedback = Application.ActiveSceneRoot.FindChild("sIBL_Feedback");
					if(feedback != null)
						connectFeedbackToDependencies(feedback, createBackground, createLighting, createReflection, useDualSkydomeSetup, selectedPasses);
					progressBar.Increment();

					// Ground Creation.
					if(createGround)
						getGround(feedbackRadius);
					progressBar.Increment();

					// Linear Workflow Activation.
					if(activateLinearWorkflow)
						activateSceneColorManagement(createBackground, useArnoldGammaCorrection, selectedPasses);
					progressBar.Increment();

					progressBar.Visible = false;

					SetCurrentLayer(layer);

					scriptEditorVerbose(true);
					autoInspectState(true);

					LogMessage("sIBL_GUI | Ibl file import finished!");

					if(commandExists("sIBL_XSI_postProcessCommand"))
					{
						LogMessage("sIBL_GUI | Executing overall postprocess Command!");
						sIBL_XSI_postProcessCommand();
					}

					if(commandExists("postProcessCommand"))
					{
						LogMessage("sIBL_GUI | Executing Template specific postprocess Command!");
						postProcessCommand();
					}
				}
				else
				{
					// Restoring Active Layer.
					SetCurrentLayer(layer);

					scriptEditorVerbose(true);
					autoInspectState(true);

					LogMessage("sIBL_GUI | No Pass selected, import canceled!");
				}
			}
		}
		else
		{
			var errorMessage = "sIBL_GUI | Arnold renderer is not available, aborting Loader Script import!"
			XSIUIToolkit.Msgbox(errorMessage, siMsgCritical);
			throw (new Error(errorMessage));
		}
	}
	catch (error)
	{
		scriptEditorVerbose(true);
		autoInspectState(true);

		LogMessage("sIBL_GUI | Ibl file import Failed!", siError);
		throw (error)
	}
}

function getPasses()
{
	var passes = new ActiveXObject("XSI.Collection");
	passes.SetAsText("Passes.List.*");

	var passesChooser_customProperty = Application.ActiveSceneRoot.AddCustomProperty("passesChooser_customProperty", false);

	var passParameters = []
	for(var i = 0; i < passes.count; i++)
	{
		passParameters[i] = passesChooser_customProperty.AddParameter3(passes.item(i).name, siBool, true);
	}

	var passesChooser_customProperty_layout = passesChooser_customProperty.PPGLayout;

	passesChooser_customProperty_layout.AddGroup("Scene Passes");
	for(var i = 0; i < passes.count; i++)
	{
		passesChooser_customProperty_layout.AddItem(passes.item(i).name);
	}
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.AddRow();
	passesChooser_customProperty_layout.AddGroup("", false, 100);
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.AddGroup("Options");
	var button = passesChooser_customProperty_layout.AddButton("ToggleAll", "Toggle All");
	button.SetAttribute(siUICX, 96)
	button = passesChooser_customProperty_layout.AddButton("UnToggleAll", "UnToggle All");
	button.SetAttribute(siUICX, 96)
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.EndRow();

	passesChooser_customProperty_layout.Logic = ToggleAll_OnClicked.toString() + UnToggleAll_OnClicked.toString();
	passesChooser_customProperty_layout.Language = "JScript";

	var returnValue = InspectObj(passesChooser_customProperty, "", "sIBL GUI Passes Chooser", siModal, false);

	if(!returnValue)
	{
		var selectedPasses = [];
		for(var i = 0; i < passParameters.length; i++)
		{
			if(passParameters[i].value == true)
			{
				selectedPasses[selectedPasses.length] = "Passes." + passParameters[i].name;
			}
		}
		deleteRequestedProperties("passesChooser_customProperty");
		return selectedPasses;
	}
	else
	{
		deleteRequestedProperties("passesChooser_customProperty");
		return null;
	}
}

function ToggleAll_OnClicked()
{
	// Starting At 1 To Ignore The PPG Name.
	for(var i = 1; i < PPG.Inspected.Item(0).Parameters.count; i++)
	{
		var boolean = "True";
		PPG.Inspected.Item(0).Parameters(i).value = boolean;
	}
}

function UnToggleAll_OnClicked()
{
	// Starting At 1 To Ignore The PPG Name.
	for(var i = 1; i < PPG.Inspected.Item(0).Parameters.count; i++)
	{
		var boolean = "False";
		PPG.Inspected.Item(0).Parameters(i).value = boolean;
	}
}

function hideSceneLights()
{
	var lights = Application.ActiveSceneRoot.FindChildren("", siLightPrimType);
	for(var i = 0; i < lights.count; i++)
	{
		lights(i).Properties("visibility").Parameters("viewvis").value = 0;
		lights(i).Properties("visibility").Parameters("rendvis").value = 0;
	}
}

function passesEnvironmentShaderStackParametersDeletion()
{
	var passes = new ActiveXObject("XSI.Collection");
	passes.SetAsText("Passes.List.*");
	var passParameters = [];
	for(var i = 0; i < passes.count; i++)
	{
		environmentShaderStack = passes.item(i).NestedObjects("EnvironmentShaderStack");
		for(var j = environmentShaderStack.Parameters.Count - 1; j >= 0; j--)
		{
			if(environmentShaderStack.Parameters.item(j).Sources.Count == 0)
				environmentShaderStack.Remove( j );
		}
	}
}

function environmentDeletion()
{
	try
	{
		// sIBL Transform Group Deletion.
		var controlsGroup = Application.ActiveSceneRoot.FindChild("sIBL");
		if(controlsGroup != null)
		{
			Application.DeleteObj("B:sIBL");
		}

		// sIBL Clips Deletion.
		DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL", false));

		// sIBL Shaders Deletion.
		DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL", false));

		// sIBL Materials Deletion.
		DeleteObj(getMatchingObjectsByClassID("{4C4F7500-51EF-11D0-854E-00A02417D029}", "sIBL", false));

		// sIBL Environment Shader Stack Parameters Deletion.
		passesEnvironmentShaderStackParametersDeletion()

		// sIBL Display Layers Deletion.
		DeleteObj(getMatchingObjectsByClassID("{479F2E10-3900-11D1-B0B3-00A024C79287}", "sIBL", false));
	}
	catch (error)
	{
	}
}

function getEnvironmentShaderBranch(container, imageSource, flipHorizontal, flipVertical, inputShader, connectionPorts, name)
{
	var imageShader = CreateShaderFromProgID("Softimage.txt2d-image-explicit.1.0", container);
	SIConnectShaderToCnxPoint(imageSource, imageShader + ".tex", false);
	if(flipHorizontal)
		imageShader.repeats.x = -1;
	if(flipVertical)
		imageShader.repeats.y = -1;

	var colorMathBasicShader = CreateShaderFromProgID("Softimage.sib_color_math_basic.1.0", container);
	colorMathBasicShader.Parameters("op").value = 2;
	SIConnectShaderToCnxPoint(imageShader, colorMathBasicShader + ".input1", false);

	var color_Math_ExponentShader = CreateShaderFromProgID("Softimage.sib_color_math_exponent.1.0", container);
	SIConnectShaderToCnxPoint(colorMathBasicShader, color_Math_ExponentShader + ".input", false);

	var colorMathBasicGammaShader = CreateShaderFromProgID("Softimage.sib_color_math_basic.1.0", container);
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		colorMathBasicGammaShader.Parameters("input1").Parameters(subComponents[i]).value = 1;
	colorMathBasicGammaShader.Parameters("op").value = 3;
	SIConnectShaderToCnxPoint(colorMathBasicGammaShader, color_Math_ExponentShader + ".factor", false);

	var colorBooleanSwitchShader = CreateShaderFromProgID("Softimage.sib_color_switch.1.0", container);
	for(var i = 0; i < subComponents.length; i++)
		colorBooleanSwitchShader.Parameters("input2").Parameters(subComponents[i]).value = 0;
	SIConnectShaderToCnxPoint(color_Math_ExponentShader, colorBooleanSwitchShader + ".input1", false);

	for(var i = 0; i < connectionPorts.length; i++)
		SIConnectShaderToCnxPoint(colorBooleanSwitchShader, inputShader + "." + connectionPorts[i], false);

	imageShader.Parameters("name").value = name + "_Image";
	colorMathBasicShader.Parameters("name").value = name + "_Color_Math_Basic";
	color_Math_ExponentShader.Parameters("name").value = name + "_Color_Math_Exponent";
	colorMathBasicGammaShader.Parameters("name").value = name + "_Gamma_Color_Math_Basic";
	colorBooleanSwitchShader.Parameters("name").value = name + "_Color_Boolean_Switch";

	return colorBooleanSwitchShader
}

function getEnvironment(createBackground, createLighting, createReflection, backgroundFilePath, lightingFilePath, reflectionFilePath, useDualSkydomeSetup, useReflectionForLighting, passes)
{
	var pass = passes[0];

	var skyShader = CreateShaderFromPreset(getShadersPath() + "Shaders/Environment/sky.Preset", pass);
	skyShader.Parameters("format").value = "latlong";
	skyShader.Parameters("X").Parameters("x").value = -1;
	SIConnectShaderToCnxPoint(skyShader, pass + ".EnvironmentShaderStack", false);

	var raySwitchShader = CreateShaderFromPreset(getShadersPath() + "Shaders/Material/ray_switch.Preset", pass);
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		raySwitchShader.Parameters("shadow").Parameters(subComponents[i]).value = 0;
	SIConnectShaderToCnxPoint(raySwitchShader, skyShader + ".color", false);

	var ports = ["camera", "shadow", "reflection", "refraction", "diffuse", "glossy"];
	for(var i = 0; i < ports.length; i++)
	{
		for(var j = 0; j < subComponents.length; j++)
			raySwitchShader.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
	}

	if(createBackground)
	{
		var backgroundSource = Application.CreateImageClip2(backgroundFilePath, "sIBL_Background_Clip");

		ports = ["camera"];
		getEnvironmentShaderBranch(pass, backgroundSource, false, false, raySwitchShader, ports, "sIBL_Background");
	}

	if(createLighting)
	{
		if(useReflectionForLighting)
			var sourceImage = reflectionFilePath;
		else
			var sourceImage = lightingFilePath;

		var lightingSource = Application.CreateImageClip2(sourceImage, "sIBL_Lighting_Clip");

		if(useDualSkydomeSetup)
			getSkydomeLight(lightingSource, "sIBL_Diffuse_Skydome", true, false );
		else
			getSkydomeLight(lightingSource, "sIBL_Skydome", true, true );
	}

	if(createReflection)
	{
		var reflectionSource = Application.CreateImageClip2(reflectionFilePath, "sIBL_Reflection_Clip");

		if(useDualSkydomeSetup)
			getSkydomeLight(reflectionSource, "sIBL_Specular_Skydome", false, true );

		ports = ["reflection", "refraction"];
		getEnvironmentShaderBranch(pass, reflectionSource, false, false, raySwitchShader, ports, "sIBL_Reflection");
	}

	// Connecting The Raytype Shader To Others Passes.
	for(var i = 1; i < passes.length; i++)
	{
		SIConnectShaderToCnxPoint(skyShader, passes[i] + ".EnvironmentShaderStack", false);
	}

	skyShader.Parameters("name").value = "sIBL_Sky";
	raySwitchShader.Parameters("name").value = "sIBL_RaySwitch";
}

function getSIBLControls(controlsGroup)
{
	var controls_customProperty = controlsGroup.AddCustomProperty("Smart_IBL_Controls", false);

	// Render Togglers Parameters.
	controls_customProperty.AddParameter3("Background_Toggle", siBool, true);
	controls_customProperty.AddParameter3("Reflection_Toggle", siBool, true);
	controls_customProperty.AddParameter3("Lighting_Toggle", siBool, true);

	var slots = ["Background", "Reflection", "Lighting"];
	var components = ["Gamma", "Gain"];

	for(var i = 0; i < slots.length; i++)
	{
		for(var j = 0; j < components.length; j++)
			controls_customProperty.AddParameter3(slots[i] + "_" + components[j], siFloat, 1, 0, 10);
	}

	var controls_customProperty_layout = controls_customProperty.PPGLayout;

	controls_customProperty_layout.AddGroup("Render Togglers");
	controls_customProperty_layout.AddItem("Background_Toggle", "Background");
	controls_customProperty_layout.AddItem("Reflection_Toggle", "Reflection");
	controls_customProperty_layout.AddItem("Lighting_Toggle", "Lighting");
	controls_customProperty_layout.EndGroup();

	for(var i = 0; i < slots.length; i++)
	{
		controls_customProperty_layout.AddGroup(slots[i] + " Color Correction");
		for(var j = 0; j < components.length; j++)
			controls_customProperty_layout.AddItem(slots[i] + "_" + components[j], components[j]);
		controls_customProperty_layout.EndGroup();
	}
}

function getControlsGroup()
{
	var controlsGroup = Application.ActiveSceneRoot.FindChild("sIBL");

	if(controlsGroup == null)
	{
		var null_ = ActiveSceneRoot.AddPrimitive("Null", "helperNull");
		var controlsGroup = Application.CreateTransformGroup("sIBL", "B:" + null_);

		var locks = ["sclx", "scly", "sclz", "rotx", "roty", "rotz", "posx", "posy", "posz"];
		var globalKinematics = controlsGroup.Kinematics.Global.Parameters;
		for(var i = 0; i < locks.length; i++)
			globalKinematics(locks[i]).SetLock(siLockLevelManipulation);

		localKinematics = controlsGroup.Kinematics.Local.Parameters;
		for(var i = 0; i < locks.length; i++)
			localKinematics(locks[i]).SetLock(siLockLevelManipulation);

		DeleteObj(null_);

		getSIBLControls(controlsGroup)
	}

	return controlsGroup
}

function getFeedbackGeometry(feedbackRadius, displayFeedback)
{
	var feedback = ActiveSceneRoot.AddGeometry("Sphere", "NurbsSurface", "sIBL_Feedback");
	feedback.properties("visibility").Parameters("rendvis").value = 0;

	if(!displayFeedback)
		feedback.properties("visibility").Parameters("viewvis").value = 0;

	CreateProjection(feedback, siTxtUV, siTxtDefaultPlanarXY, null, "sIBL_Texture_Projection");

	// Object Oriented Trick To Shift UVs By "-0.125".
	samplesCluster= feedback.ActivePrimitive.Geometry.Clusters.Filter( "sample" )(0)
	uvsProjection = samplesCluster.Properties.Filter("uvspace")(0)
	feedBackProjectionChildren = uvsProjection.NestedObjects;
	for(var i = 0; i < feedBackProjectionChildren.Count; i++)
	{
		if(feedBackProjectionChildren(i).type == "uvprojdef" )
		{
			feedBackProjectionChildren(i).Parameters( "projtrsu" ).value = -0.125;
			FreezeUVWTransformation(feedBackProjectionChildren(i));
			FreezeObj(samplesCluster)
			break;
		}

	}

	var globalKinematics = feedback.Kinematics.Global.Parameters;
	globalKinematics("sclx").value = -globalKinematics("sclx").value;
	ResetTransform(feedback, siCtr, siSRT, siXYZ);
	globalKinematics("sclx").value = feedbackRadius;
	globalKinematics("scly").value = feedbackRadius;
	globalKinematics("sclz").value = feedbackRadius;

	ApplyTopoOp("Inverse", feedback, 3, siImmediateOperation);

	addToDisplayLayer("sIBL_Feedback_Layer", feedback);

	return feedback;
}

function getFeedback(feedbackRadius, createBackground, displayFeedback)
{
	var controlsGroup = getControlsGroup();
	var feedback = getFeedbackGeometry(feedbackRadius, displayFeedback);

	controlsGroup.AddChild(feedback);

	var feedbackMaterial = SICreateMaterial("$XSI_DSPRESETS/Shaders/Material/Constant.Preset", "sIBL_Feedback_Material");

	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		feedbackMaterial.Parameters("Surface").NestedObjects(0).Parameters("transparency").Parameters(subComponents[i]).value = 0.5;

	AssignMaterial(feedbackMaterial + "," + feedback);
	if(createBackground)
		SIConnectShaderToCnxPoint("Clips.sIBL_Background_Clip", feedbackMaterial + ".sIBL_Feedback_Material.color");

	return feedback
}

function getSkydomeLight(imageSource, name, affectDiffuse, affectSpecular)
{
	var controlsGroup = getControlsGroup();

	var light = ActiveSceneRoot.AddPrimitive("LightSun.Preset", name);
	var lightShader = CreateShaderFromPreset(getShadersPath() + "Shaders/Light/arnold_skydome_light.Preset", light);
	SIConnectShaderToCnxPoint(lightShader, light + ".LightShader", false);

	var inputShader = getEnvironmentShaderBranch(lightShader, imageSource, true, false, "", "", name);
	SIConnectShaderToCnxPoint(inputShader, lightShader + ".color", false);

	//TODO: Remove Following Line When SItoA Gets Updated.
	lightShader.intensity.value = 0.318309;
	lightShader.resolution.value = GetValue(imageSource + ".Source.XRes");
	lightShader.format.value = 2;
	lightShader.affect_diffuse.value = affectDiffuse;
	lightShader.affect_specular.value = affectSpecular;

	controlsGroup.AddChild(light);

	var locks = ["sclx", "scly", "sclz", "posx", "posy", "posz"];
	var globalKinematics = light.Kinematics.Global.Parameters;
	for(var i = 0; i < locks.length; i++)
		globalKinematics(locks[i]).SetLock(siLockLevelManipulation);

	lightShader.Parameters("name").value = "sIBL_Arnold_Skydome_Light";
}

function getLight(parent, constraintParent, type, name, scale, intensity, color, uCoordinate, vCoordinate)
{
	switch(type)
	{
		case "Distant":
			var primitiveType = "Infinite";
			var shaderType = "arnold_distant_light";
			break;
		case "Point":
			var primitiveType = "Point";
			var shaderType = "arnold_point_light";
			break;
		case "Quad":
			var primitiveType = "Light_Box";
			var shaderType = "arnold_quad_light";
			break;
		case "Spot":
			var primitiveType = "Spot";
			var shaderType = "arnold_spot_light";
			break;
	}

	var light = ActiveSceneRoot.AddPrimitive(primitiveType + ".Preset", name);
	var lightShader = CreateShaderFromPreset(getShadersPath() + "Shaders/Light/" + shaderType, light);
	SIConnectShaderToCnxPoint(lightShader, light + ".LightShader", false);

	light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("intensity").value = intensity;
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("color").Parameters(subComponents[i]).value = color[i] / 255;

	light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("samples").value = 4;

	switch(type)
	{
		case "Distant":
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("angle").value = 2;
			break;
		case "Point":
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("radius").value = 4;
			break;
		case "Quad":
			var subComponents = ["SX", "SY", "SZ"];
			for(var i = 0; i < subComponents.length; i++)
				light.Primitives("light").Parameters("LightAreaXform" + subComponents[i]).value = 1;
			break;
		case "Spot":
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("radius").value = 8;
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("cone_angle").value = 96;
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("penumbra_angle").value = 16;
			break;
	}

	parent.AddChild(light);

	var globalKinematics = light.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = scale;

	var surfaceConstraint = ApplyCns("Surface", light, constraintParent);

	if(objectExists("sIBL_Lights_Target"))
	{
		var lightTarget = Application.ActiveSceneRoot.FindChild("sIBL_Lights_Target");
	}
	else
	{
		var lightTarget = ActiveSceneRoot.AddPrimitive("Null", "sIBL_Lights_Target");
	}

	parent.AddChild(lightTarget)

	var directionConstraint = ApplyCns("Direction", light, lightTarget);

	var constraints = light.Kinematics.Constraints;
	for(var i = 0; i < constraints.Count; i++)
	{
		var constraint = constraints(i);
		if(constraint.Type == "surfcns")
		{
			// U -> V & V -> U Because Of The Invert Normal.
			constraint.Parameters("posu").Value = 0.5 + (0.5 - vCoordinate);
			var vPosition = uCoordinate - 0.125;
			if(vPosition < 0.0 )
				vPosition = 1 + vPosition;
			constraint.Parameters("posv").Value = vPosition;
		}
		if(constraint.Type == "dircns")
		{
			constraint.Parameters("dirx").Value = 0;
			constraint.Parameters("dirz").Value = -1;
			constraint.Parameters("upvct_active").Value = 1;
		}
	}

	addToDisplayLayer("sIBL_Lighting_Layer", lightTarget);
	addToDisplayLayer("sIBL_Lighting_Layer", light);

	lightShader.Parameters("name").value = "sIBL_Arnold_" + shaderType + "_Light";
}

function getSun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius)
{
	var controlsGroup = getControlsGroup();
	var feedback = Application.ActiveSceneRoot.FindChild("sIBL_Feedback");

	getLight(controlsGroup, feedback, sunLightType, "sIBL_Sun", feedbackRadius / 15, sunMultiplier, sunColor, sunU, sunV)
}

function getDynamicLights(dynamicLightsType, dynamicLights, feedbackRadius)
{
	var controlsGroup = getControlsGroup();
	var feedback = Application.ActiveSceneRoot.FindChild("sIBL_Feedback");
	var dynamicLights = dynamicLights.split("|");
	for(var i = 0; i < dynamicLights.length; i += 8)
		getLight(controlsGroup, feedback, dynamicLightsType, "sIBL_DKL_" + dynamicLights[i + 1], feedbackRadius / 15, parseFloat(dynamicLights[i + 5]), [parseFloat(dynamicLights[i + 2]), parseFloat(dynamicLights[i + 3]), parseFloat(dynamicLights[i + 4])], parseFloat(dynamicLights[i + 6]), parseFloat(dynamicLights[i + 7]))
}

function bridgeControlsAndShaders(pass, slot)
{
	AddExpr(pass + ".sIBL_" + slot + "_Color_Boolean_Switch.switch", "1-(sIBL.Smart_IBL_Controls." + slot + "_Toggle)", true);

	var components = ["red", "green", "blue"];
	for(var i = 0; i < components.length; i++)
	{
		AddExpr(pass + ".sIBL_" + slot + "_Color_Math_Basic.input2." + components[i], "sIBL.Smart_IBL_Controls." + slot + "_Gain", true);
		AddExpr(pass + ".sIBL_" + slot + "_Gamma_Color_Math_Basic.input2." + components[i], "sIBL.Smart_IBL_Controls." + slot + "_Gamma", true);
	}
}

function connectFeedbackToDependencies(feedback, connectToBackground, connectToLighting, connectToReflection, useDualSkydomeSetup, passes)
{
	var pass = passes[0];

	if(connectToBackground || connectToLighting || connectToReflection)
	{
		AddExpr(pass + ".sIBL_Sky.X_angle", "-" + feedback + ".kine.global.rotx", true);
		AddExpr(pass + ".sIBL_Sky.Y_angle", feedback + ".kine.global.roty", true);
		AddExpr(pass + ".sIBL_Sky.Z_angle", "-" + feedback + ".kine.global.rotz", true);
	}

	if(connectToBackground)
	{
		bridgeControlsAndShaders(pass, "Background");
		AddExpr(pass + ".sIBL_Sky.opaque_alpha", "sIBL.Smart_IBL_Controls.Background_Toggle", true);
	}

	if(connectToLighting || connectToReflection)
	{
		var skyDomes = ["sIBL_Skydome"];
		var slots = ["Lighting"];
		if(useDualSkydomeSetup)
		{
			skyDomes = ["sIBL_Diffuse_Skydome", "sIBL_Specular_Skydome"];
			var slots = ["Lighting", "Reflection"];
		}

		for(var i = 0; i < skyDomes.length; i++)
		{
			if(objectExists(skyDomes[i]))
			{
				AddExpr(skyDomes[i] + ".kine.global.rotx", feedback + ".kine.global.rotx", true);
				AddExpr(skyDomes[i] + ".kine.global.roty", feedback + ".kine.global.roty", true);
				AddExpr(skyDomes[i] + ".kine.global.rotz", feedback + ".kine.global.rotz", true);

				switch(skyDomes[i])
				{
					case "sIBL_Skydome" :
						AddExpr(skyDomes[i] + ".light.sIBL_Arnold_Skydome_Light.affect_diffuse", "sIBL.Smart_IBL_Controls." + slots[i] + "_Toggle", true);
						AddExpr(skyDomes[i] + ".light.sIBL_Arnold_Skydome_Light.affect_specular", "sIBL.Smart_IBL_Controls." + slots[i] + "_Toggle", true);
						RemoveCustomParam("sIBL.Smart_IBL_Controls.Reflection_Toggle");
						RemoveCustomParam("sIBL.Smart_IBL_Controls.Reflection_Gamma");
						RemoveCustomParam("sIBL.Smart_IBL_Controls.Reflection_Gain");
						break;
					case "sIBL_Diffuse_Skydome" :
						AddExpr(skyDomes[i] + ".light.sIBL_Arnold_Skydome_Light.affect_diffuse", "sIBL.Smart_IBL_Controls." + slots[i] + "_Toggle", true);
						Lock(skyDomes[i] + ".light.sIBL_Arnold_Skydome_Light.affect_specular", siLockLevelManipulation);
						break;
					case "sIBL_Specular_Skydome" :
						AddExpr(skyDomes[i] + ".light.sIBL_Arnold_Skydome_Light.affect_specular", "sIBL.Smart_IBL_Controls." + slots[i] + "_Toggle", true);
						Lock(skyDomes[i] + ".light.sIBL_Arnold_Skydome_Light.affect_diffuse", siLockLevelManipulation);
						break;
				}
				var components = ["red", "green", "blue"];
				for(var j = 0; j < components.length; j++)
				{
					AddExpr(skyDomes[i] + ".light." + skyDomes[i]  + "_Color_Math_Basic.input2." + components[j], "sIBL.Smart_IBL_Controls." + slots[i] + "_Gain", true);
					AddExpr(skyDomes[i] + ".light." + skyDomes[i]  + "_Gamma_Color_Math_Basic.input2." + components[j], "sIBL.Smart_IBL_Controls." + slots[i] + "_Gamma", true);
				}
			}
		}
	}
}

function arnoldRendererExists()
{
	var e = new Enumerator(Application.Renderers);
	for(; !e.atEnd(); e.moveNext())
		if(e.item().name == "Arnold Render")
			return true
	return false
}

function setRenderer()
{
	SetValue("Passes.RenderOptions.Renderer", "Arnold Render");

	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		ActiveSceneRoot.Properties.Item("Ambient Lighting").Parameters("ambience").Parameters(subComponents[i]).value = 0;

	SetValue("Views.ViewA.RenderRegion.UsePassOptions,Views.ViewB.RenderRegion.UsePassOptions,Views.ViewC.RenderRegion.UsePassOptions,Views.ViewD.RenderRegion.UsePassOptions", Array(true, true, true, true));
}

function activateSceneColorManagement(createBackground, useArnoldGammaCorrection, passes)
{
	if(useArnoldGammaCorrection)
	{
		var nativeColorManagement = false;
		var gammaValue = 2.2;
	}
	else
	{
		var nativeColorManagement = true;
		var gammaValue = 1;
	}

	Application.Preferences.SetPreferenceValue("Display.color_management_source", 0);
	Application.Preferences.SetPreferenceValue("Display.color_management_render_region", nativeColorManagement);
	Application.Preferences.SetPreferenceValue("Display.color_management_render_preview", nativeColorManagement);
	Application.Preferences.SetPreferenceValue("Display.color_management_shader_balls", nativeColorManagement);
	Application.Preferences.SetPreferenceValue("Display.color_management_ui_colors", nativeColorManagement);

	for(var i = 0; i < passes.length; i++)
	{
		var pass = Dictionary.GetObject(passes[i]);
		pass.Parameters("UseDisplayGammaCorrection").value = nativeColorManagement;
		var parameters = ["output_driver_gamma", "texture_gamma", "light_gamma", "shader_gamma"];
		for(var i = 0; i < parameters.length; i++)
			pass.Properties("Arnold Render Options").Parameters(parameters[i]).value = gammaValue;
	}

	if(createBackground && !useArnoldGammaCorrection)
	{
		var controls_customProperty = getRequestedPropertiesAsCollection("Smart_IBL_Controls");
		controls_customProperty.item(0).Parameters("Background_Gamma").value = 1 / 2.2;
	}

}

function getGround(feedbackRadius)
{
	var controlsGroup = getControlsGroup();

	var ground = ActiveSceneRoot.AddGeometry("Grid", "MeshSurface", "sIBL_Ground");
	controlsGroup.AddChild(ground)

	var globalKinematics = ground.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = (feedbackRadius * Math.sqrt(2)) / 2;

	ResetTransform(ground, siCtr, siSRT, siXYZ);

	addToDisplayLayer("sIBL_Ground_Layer", ground);
}

function getPluginPath()
{
	var plugin = Application.plugins("Arnold Shaders");
	return plugin.OriginPath.replace(/\\/g, "/");
}

function getShadersPath()
{
	return getPluginPath() + "../../Data/DSPresets/";
}

function objectExists(object)
{
	var seekedObject = Application.ActiveSceneRoot.FindChild(object);
	if(seekedObject != null)
		return true
	else
		return false
}

function commandExists(command)
{
	var commands = Application.Commands;

	var e = new Enumerator(commands)
	for( ; !e.atEnd(); e.moveNext() )
	{
		if(e.item() == command)
			return true
	}

	return false
}

function addToDisplayLayer(layerName, object)
{
	var sceneLayers = ActiveProject.ActiveScene.Layers;
	var layerExists = false;

	for(var i = 0; i < sceneLayers.Count; i++)
	{
		if(sceneLayers(i).name == layerName)
		{
			layerExists = true;
			break;
		}
	}

	if(!layerExists)
		CreateLayer(null, layerName, object);
	else
		MoveToLayer("Layers." + layerName, object);
}

function getSceneExtent()
{
	var meshes = getMatchingObjectsByClassID("{400CCE36-4400-11D0-BDDD-00A0241981E2}", ".*", false)
	var surfaces = getMatchingObjectsByClassID("{28DEC312-62B3-11D1-B79B-00A0243E3694}", ".*", false)
	var pointClouds = getMatchingObjectsByClassID("{2194FFE3-A0B2-4CAB-A3E8-FC8EDC9F159A}", ".*", false)

	var objects = extendCollection(meshes, surfaces);
	objects = extendCollection(objects, pointClouds);

	var parents = new ActiveXObject("XSI.Collection");
	for(var i = 0; i < objects.Count; i++)
		parents.add(objects(i).Parent);

	var sceneBoundingBox = GetBBox(parents);
	sceneBoundingBox = [sceneBoundingBox.value( "LowerBoundX" ), sceneBoundingBox.value( "LowerBoundY" ), sceneBoundingBox.value( "LowerBoundZ" ), sceneBoundingBox.value( "UpperBoundX" ), sceneBoundingBox.value( "UpperBoundY" ), sceneBoundingBox.value( "UpperBoundZ" )];
	var sceneExtent = 0
	for(var i = 0; i < sceneBoundingBox.length; i++)
		if(Math.abs(sceneBoundingBox[i]) > sceneExtent )
			sceneExtent = Math.abs(sceneBoundingBox[i]);
	return sceneExtent;
}

function truncFloatNumber(number, truncValue)
{
	if(truncValue != 0)
		return Math.round(number / truncValue) * truncValue;
	else
		return number;
}

function getExtendedFeedbackRadius(feedbackRadius)
{
	var sceneExtent = getSceneExtent();
	sceneExtent = (sceneExtent + (sceneExtent*50/100))/4;

	if(sceneExtent < feedbackRadius)
		return feedbackRadius;
	else
		return truncFloatNumber(sceneExtent,10);
}

function scriptEditorVerbose(verboseState)
{
	Application.Preferences.SetPreferenceValue("scripting.cmdlog", verboseState);
	Application.Preferences.SetPreferenceValue("scripting.msglog", verboseState);
	Application.Preferences.SetPreferenceValue("scripting.msglogverbose", verboseState);
}

function autoInspectState(autoInspectState)
{
	Application.Preferences.SetPreferenceValue("Interaction.autoinspect", autoInspectState);
}

function getRequestedPropertiesAsCollection(propertyType)
{
	var properties = getByClassIDAsCollection("{76332571-D242-11d0-B69C-00AA003B3EA6}");

	if(properties.count != 0)
	{
		var propertiesListAsStringArray = getCollectionAsStringArray(properties);

		var regexPattern = new RegExp(propertyType + "\\w*");

		var requestedProperties = new Array();

		for(var i = 0; i < propertiesListAsStringArray.length; i++)
		{
			var propertyFound = propertiesListAsStringArray[i].match(regexPattern);

			if(propertyFound)
				requestedProperties[requestedProperties.length] = propertiesListAsStringArray[i];
		}

		var requestedPropertiesAsCollection = new ActiveXObject("XSI.Collection");

		if(requestedProperties.length != 0)
			requestedPropertiesAsCollection = getStringArrayAsCollection(requestedProperties);

		return requestedPropertiesAsCollection;
	}
	else
	{
		return 0;
	}
}

function deleteRequestedProperties(propertyType)
{
	var requestedProperties = getRequestedPropertiesAsCollection(propertyType);

	for(var i = 0; i < requestedProperties.count; i++)
		DeleteObj(requestedProperties.item(i));
}

function getByClassIDAsCollection(currentClassID)
{
	var nodesByClassID = new ActiveXObject("XSI.Collection");

	nodesByClassID = FindObjects(null, currentClassID);

	return nodesByClassID;
}

function getCollectionAsStringArray(currentCollection)
{
	var collectionObjectsAsString = currentCollection.GetAsText();
	var collectionObjects = collectionObjectsAsString.split(",");

	return collectionObjects;
}

function getStringArrayAsCollection(currentStringArray)
{
	var stringArrayAsCollection = new ActiveXObject("XSI.Collection");
	stringArrayAsCollection.SetAsText(currentStringArray);

	return stringArrayAsCollection;
}

function extendCollection(initialCollection, extensionCollection)
{
	for(var i = 0; i < extensionCollection.Count; i++)
		initialCollection.Add(extensionCollection(i));
	return initialCollection;
}

function getMatchingObjectsByClassID(classID, pattern, matchExact)
{
	var objectsByClassID = new ActiveXObject("XSI.Collection");
	objectsByClassID = FindObjects(null, classID);
	matchingObjects = new ActiveXObject("XSI.Collection");
	for(var i = 0; i < objectsByClassID.Count; i++)
	{
		if(matchExact)
		{
			if(objectsByClassID(i).name == pattern)
				matchingObjects.Add(objectsByClassID(i));
		}
		else
		{
			if(objectsByClassID(i).name.match(pattern))
				matchingObjects.Add(objectsByClassID(i));
		}
	}
	return matchingObjects;
}