[Template]
Name = @Name | Softimage Mental Ray Standard | String | Template Name
Path = @Path | | String | Template Path
HelpFile = @HelpFile | help/Softimage_MR_Standard_Template_Manual.html | String | Help File
Release = @Release | 1.1.3 | String | Template Release
Date = @Date | 11 March 2011 | String | Date
Author = @Author | Kel Solaar | String | Author
Email = @Email | thomas.mansencal@gmail.com | String | Email
Url = @Url | http://thomasmansencal.com/ | String | Url
Software = @Software | Softimage | String | Software
Version = @Version | 2011 | String | Version
Renderer = @Renderer | Mental Ray | String | Renderer
OutputScript = @OutputScript | sIBL_XSI_Import.js | String | Output Script
Comment = @Comment | This is Softimage 2011 Mental Ray Template. | String | Comment

[Ibl Set Attributes]
Background|BGfile = @BGfile
Reflection|REFfile = @REFfile
Reflection|REFmulti = @REFmulti
Reflection|REFgamma = @REFgamma
Enviroment|EVfile = @EVfile
Enviroment|EVmulti = @EVmulti
Enviroment|EVgamma = @EVgamma
Sun|SUNu = @SUNu
Sun|SUNv = @SUNv
Sun|SUNcolor = @SUNcolor
Sun|SUNmulti = @SUNmulti
Lights|DynamicLights = @dynamicLights
Header|Height = @Height
Header|North = @North

[Common Attributes]
createBackground = @createBackground | 1 | Boolean | Create / Update Background
createReflection = @createReflection | 1 | Boolean | Create / Update Reflection
createLighting = @createLighting | 1 | Boolean | Create / Update Lighting
createSun = @createSun | 1 | Boolean | Create / Update Sun
createLights = @createLights | 1 | Boolean | Create Dynamic Lights

[Additional Attributes]
showPassesDialog = @showPassesDialog | 0 | Boolean | Passes Selection Dialog
updateScene = @updateScene | 0 | Boolean | Update Scene
overrideTweaks = @overrideTweaks | 0 | Boolean | Override User Tweaks
displayFeedback = @displayFeedback | 1 | Boolean | Display Feedback
sunLightType = @sunLightType | Infinite;Light Box;Spot;Point | Enum | Sun Light Type
dynamicLightsType = @dynamicLightsType | Infinite;Light Box;Spot;Point | Enum | Dynamic Lights Type
hideLights = @hideLights | 1 | Boolean | Hide Lights
createGround = @createGround | 1 | Boolean | Create Ground
shadowCatcher = @shadowCatcher | 1 | Boolean | Ground Shadow Catcher
physicalSun = @physicalSun | 1 | Boolean | Physical Sun
activateFinalGather = @activateFinalGather | 1 | Boolean | Activate Final Gather
activateColorManagement = @activateColorManagement | 1 | Boolean | Activate Color Management

[Remote Connection]
ConnectionType = @ConnectionType | Socket | String | Connection Type
ExecutionCommand = @ExecutionCommand | $loaderScriptPath | String | ExecutionCommand
DefaultAddress = @DefaultAddress | 127.0.0.1 | Integer | Default Address
DefaultPort = @DefaultPort | 12288 | Integer | Default Port

[Script]
// @OutputScript - @Release for @Software @Version
// Author: @Author
// EMail: @Email
// Homepage: @Url
// Template path: @Path
// Template last modified: @Date
// sIBL_GUI
var backgroundFilePath = "@BGfile";
var reflectionFilePath = "@REFfile";
var reflectionMultiplier = @REFmulti;
var reflectionGamma = @REFgamma;
var lightingFilePath = "@EVfile";
var lightingMultiplier = @EVmulti;
var lightingGamma = @EVgamma;
var sunU = @SUNu;
var sunV = @SUNv;
var sunColor = [@SUNcolor];
var sunMultiplier = @SUNmulti;
var dynamicLights = "@dynamicLights";
var height = @Height;
var north = @North;
var createBackground = @createBackground;
var createReflection = @createReflection;
var createLighting = @createLighting;
var createSun = @createSun;
var createLights = @createLights;
var showPassesDialog = @showPassesDialog;
var updateScene = @updateScene;
var overrideTweaks = @overrideTweaks;
var displayFeedback = @displayFeedback;
var feedbackRadius = 100;
var sunLightType = "@sunLightType";
var dynamicLightsType = "@dynamicLightsType";
var hideLights = @hideLights;
var createGround = @createGround;
var shadowCatcher = @shadowCatcher;
var physicalSun = @physicalSun;
var activateFinalGather = @activateFinalGather;
var activateColorManagement = @activateColorManagement;

var proceedSetup = true;
if(backgroundFilePath == "-1" || reflectionFilePath == "-1" || lightingFilePath == "-1")
{
	var result = XSIUIToolkit.Msgbox( "sIBL_GUI | Non Template compatible Ibl Set provided: Unpredictable results may occur! Would you like to proceed anyway?", siMsgYesNo | siMsgQuestion, "sIBL_GUI " ) ;
	if (result == siMsgNo )
		proceedSetup = false;
}
if(proceedSetup)
	setup(backgroundFilePath,
				reflectionFilePath,
				reflectionMultiplier,
				reflectionGamma,
				lightingFilePath,
				lightingMultiplier,
				lightingGamma,
				sunU,
				sunV,
				sunColor,
				sunMultiplier,
				dynamicLights,
				height,
				north,
				createBackground,
				createReflection,
				createLighting,
				createSun,
				createLights,
				showPassesDialog,
				updateScene,
				overrideTweaks,
				displayFeedback,
				feedbackRadius,
				sunLightType,
				dynamicLightsType,
				hideLights,
				createGround,
				shadowCatcher,
				physicalSun,
				activateFinalGather,
				activateColorManagement);
else
	LogMessage("sIBL_GUI | Ibl file import aborted!");

function setup(backgroundFilePath,
					reflectionFilePath,
					reflectionMultiplier,
					reflectionGamma,
					lightingFilePath,
					lightingMultiplier,
					lightingGamma,
					sunU,
					sunV,
					sunColor,
					sunMultiplier,
					dynamicLights,
					height,
					north,
					createBackground,
					createReflection,
					createLighting,
					createSun,
					createLights,
					showPassesDialog,
					updateScene,
					overrideTweaks,
					displayFeedback,
					feedbackRadius,
					sunLightType,
					dynamicLightsType,
					hideLights,
					createGround,
					shadowCatcher,
					physicalSun,
					activateFinalGather,
					activateColorManagement)
{
	try
	{
		if(commandExists("sIBL_XSI_preProcessCommand"))
		{
			LogMessage("sIBL_GUI | Executing overall preprocess Command!");
			sIBL_XSI_preProcessCommand();
		}

		if(commandExists("preProcessCommand"))
		{
			LogMessage("sIBL_GUI | Executing Template specific preprocess Command!");
			preProcessCommand();
		}

		// Storing Active Layer.
		var layer = ActiveProject.ActiveScene.ActiveLayer;

		var selectedPasses = [];

		if(showPassesDialog)
			selectedPasses = getPasses();
		else
			selectedPasses[0] = GetCurrentPass();

		if(selectedPasses != null)
		{

			if(selectedPasses.length != 0)
			{
				var progressBar = XSIUIToolkit.ProgressBar;
				progressBar.Maximum = 100;
				progressBar.CancelEnabled = false;

				// Defines Sun And Dynamic Lights Existence From Ibl file.
				if(sunU != -1 && sunV != -1)
					var sunExists = true;
				else
					var sunExists = false;

				if(dynamicLights != -1)
					var dynamicLightsExists = true
				else
					var dynamicLightsExists = false

				if(updateScene)
				{
					LogMessage("sIBL_GUI | Starting sIBL related nodes update!");
					progressBar.Caption = "sIBL_GUI | Updating Scene!";

					var controlsGroup = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL", true);
					controlsGroup = controlsGroup(0);

					if(controlsGroup != null)
					{
						scriptEditorVerbose(false);
						autoInspectState(false);

						progressBar.Step = 16.666;
						progressBar.Visible = true;

						// Scene Cleanup.
						update_environmentDeletion(overrideTweaks, createBackground, createLighting, createReflection, createSun, createLights, sunExists, dynamicLightsExists, createGround)
						progressBar.Increment();

						// Defines Updated sIBL_Feedback Radius From Scene Extent.
						feedbackRadius = update_getExtendedFeedbackRadius(feedbackRadius);

						// Environment Shaders Update.
						update_environmentShaders(createBackground, createLighting, createReflection, backgroundFilePath, lightingFilePath, reflectionFilePath, selectedPasses, overrideTweaks);
						progressBar.Increment();

						// Feedback Update.
						if(overrideTweaks)
							update_feedback(feedbackRadius, createBackground, displayFeedback);
						progressBar.Increment();

						// Sun Update.
						if(sunExists)
						{
							if(createSun)
							{
								update_sun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius, overrideTweaks);
							}
						}
						progressBar.Increment();

						// Dynamic Lights Update.
						if(dynamicLightsExists)
						{
							if(createLights)
							{
								update_dynamicsLights(dynamicLightsType, dynamicLights, feedbackRadius);
							}
						}
						progressBar.Increment();

						if(createGround)
						{
							update_ground(feedbackRadius, shadowCatcher, overrideTweaks);
						}
						progressBar.Increment();

						progressBar.Visible = false;
					}
					else
					{
						LogMessage("sIBL_GUI | No sIBL group found, aborting scene update!", siWarning);
					}

				}
				else
				{
					LogMessage("sIBL_GUI | Starting Ibl file import!");
					progressBar.Caption = "sIBL_GUI | Importing Ibl file!";

					scriptEditorVerbose(false);
					autoInspectState(false);

					progressBar.Step = 11;
					progressBar.Visible = true;

					// Scene Cleanup.
					environmentDeletion();
					progressBar.Increment();

					// Defines sIBL_Feedback Radius From Scene Extent.
					feedbackRadius = getExtendedFeedbackRadius(feedbackRadius);

					// Activating Renderer.
					setRenderer();
					progressBar.Increment();

					// Lights Hide.
					if(hideLights)
						hideSceneLights();
					progressBar.Increment();

					// Environment Shaders Creation.
					getEnvironmentShaders(createBackground, createLighting, createReflection, backgroundFilePath, lightingFilePath, reflectionFilePath, selectedPasses);
					progressBar.Increment();

					// Feedback Creation.
					getFeedback(feedbackRadius, createBackground, displayFeedback);
					progressBar.Increment();

					// Sun Creation.
					if(sunExists)
					{
						if(createSun)
						{
							if(objectExists("sIBL_Feedback"))
							{
								getSun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius, physicalSun);
							}
						}
					}
					progressBar.Increment();

					// Dynamic Lights Creation.
					if(dynamicLightsExists)
					{
						if(createLights)
						{
							getDynamicLights(dynamicLightsType, dynamicLights, feedbackRadius);
						}
					}
					progressBar.Increment();

					// Shaders / Feedback Connection.
					var feedback = Application.ActiveSceneRoot.FindChild("sIBL_Feedback");
					if(feedback != null)
						connectFeedbackToShaders(feedback, createBackground, createLighting, createReflection, selectedPasses);
					progressBar.Increment();

					// Ground Creation.
					if(createGround)
						getGround(feedbackRadius, shadowCatcher);
					progressBar.Increment();

					// Final Gather Activation.
					if(activateFinalGather)
						activateFinalGather(selectedPasses);
					progressBar.Increment();

					// Linear Workflow Activation.
					if(activateColorManagement)
						activateSceneColorManagement(createBackground, selectedPasses);
					progressBar.Increment();

					progressBar.Visible = false;
				}

				SetCurrentLayer(layer);

				scriptEditorVerbose(true);
				autoInspectState(true);

				if(updateScene)
					LogMessage("sIBL_GUI | Ibl file update finished!");
				else
					LogMessage("sIBL_GUI | Ibl file import finished!");

				if(commandExists("sIBL_XSI_postProcessCommand"))
				{
					LogMessage("sIBL_GUI | Executing overall postprocess Command!");
					sIBL_XSI_postProcessCommand();
				}

				if(commandExists("postProcessCommand"))
				{
					LogMessage("sIBL_GUI | Executing Template specific postprocess Command!");
					postProcessCommand();
				}
			}
			else
			{
				// Restoring Active Layer.
				SetCurrentLayer(layer);

				scriptEditorVerbose(true);
				autoInspectState(true);

				LogMessage("sIBL_GUI | No Pass selected, import canceled!");
			}
		}
	}
	catch (error)
	{
		scriptEditorVerbose(true);
		autoInspectState(true);

		LogMessage("sIBL_GUI | Ibl file import Failed!", siError);
		throw (error)
	}
}

function getPasses()
{
	var passes = new ActiveXObject("XSI.Collection");
	passes.SetAsText("Passes.List.*");

	var passesChooser_customProperty = Application.ActiveSceneRoot.AddCustomProperty("passesChooser_customProperty", false);

	var passParameters = []
	for(var i = 0; i < passes.count; i++)
	{
		passParameters[i] = passesChooser_customProperty.AddParameter3(passes.item(i).name, siBool, true);
	}

	var passesChooser_customProperty_layout = passesChooser_customProperty.PPGLayout;

	passesChooser_customProperty_layout.AddGroup("Scene Passes");
	for(var i = 0; i < passes.count; i++)
	{
		passesChooser_customProperty_layout.AddItem(passes.item(i).name);
	}
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.AddRow();
	passesChooser_customProperty_layout.AddGroup("", false, 100);
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.AddGroup("Options");
	var button = passesChooser_customProperty_layout.AddButton("ToggleAll", "Toggle All");
	button.SetAttribute(siUICX, 96)
	button = passesChooser_customProperty_layout.AddButton("UnToggleAll", "UnToggle All");
	button.SetAttribute(siUICX, 96)
	passesChooser_customProperty_layout.EndGroup();
	passesChooser_customProperty_layout.EndRow();

	passesChooser_customProperty_layout.Logic = ToggleAll_OnClicked.toString() + UnToggleAll_OnClicked.toString();
	passesChooser_customProperty_layout.Language = "JScript";

	var returnValue = InspectObj(passesChooser_customProperty, "", "sIBL GUI Passes Chooser", siModal, false);

	if(!returnValue)
	{
		var selectedPasses = [];
		for(var i = 0; i < passParameters.length; i++)
		{
			if(passParameters[i].value == true)
			{
				selectedPasses[selectedPasses.length] = "Passes." + passParameters[i].name;
			}
		}
		deleteRequestedProperties("passesChooser_customProperty");
		return selectedPasses;
	}
	else
	{
		deleteRequestedProperties("passesChooser_customProperty");
		return null;
	}
}

function ToggleAll_OnClicked()
{
	// Starting At 1 To Ignore The PPG Name.
	for(var i = 1; i < PPG.Inspected.Item(0).Parameters.count; i++)
	{
		var boolean = "True";
		PPG.Inspected.Item(0).Parameters(i).value = boolean;
	}
}

function UnToggleAll_OnClicked()
{
	// Starting At 1 To Ignore The PPG Name.
	for(var i = 1; i < PPG.Inspected.Item(0).Parameters.count; i++)
	{
		var boolean = "False";
		PPG.Inspected.Item(0).Parameters(i).value = boolean;
	}
}

function hideSceneLights()
{
	var lights = Application.ActiveSceneRoot.FindChildren("", siLightPrimType);
	for(var i = 0; i < lights.count; i++)
	{
		lights(i).Properties("visibility").Parameters("viewvis").value = 0;
		lights(i).Properties("visibility").Parameters("rendvis").value = 0;
	}
}

function update_environmentDeletion(overrideTweaks, createBackground, createLighting, createReflection, createSun, createLights, sunExists, dynamicLightsExists, createGround)
{
	try
	{
		// sIBL Clip Shaders Deletion.
		if(overrideTweaks)
		{
			if(!createLighting)
				DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL_Lighting_Clip", true));
			if(!createReflection)
				DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL_Reflection_Clip", true));
		}

		// sIBL Environment Shaders Deletion.
		if(overrideTweaks)
		{
			if(!createBackground)
				DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Background_Mib_Lookup_Spherical", true));
			if(!createLighting)
			{
			}
			DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Lighting_Mib_Lookup_Spherical", true));
			if(!createReflection)
				DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Reflection_Mib_Lookup_Spherical", true));
		}

		if(overrideTweaks)
		{
			if(!createSun)
				DeleteObj(getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_Sun", true));
		}

		if(overrideTweaks)
		{
			if(!createLights)
				DeleteObj(getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_DKL_", false));
		}

		if(overrideTweaks)
		{
			if(!createGround)
			{
				DeleteObj(getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_Ground", true));
				DeleteObj(getMatchingObjectsByClassID("{479F2E10-3900-11D1-B0B3-00A024C79287}", "sIBL_Ground_Layer", true));
			}
		}
	}
	catch (error)
	{
	}
}

function environmentDeletion()
{
	try
	{
		// sIBL Transform Group Deletion.
		var controlsGroup = Application.ActiveSceneRoot.FindChild("sIBL");
		if(controlsGroup != null)
		{
			Application.DeleteObj("B:sIBL");
		}

		// sIBL Clips Deletion.
		DeleteObj(getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL", false));

		// sIBL Shaders Deletion.
		DeleteObj(getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL", false));

		// sIBL Environment Shader Stack Parameters Deletion.
		passesEnvironmentShaderStackParametersDeletion()

		// sIBL Display Layers Deletion.
		DeleteObj(getMatchingObjectsByClassID("{479F2E10-3900-11D1-B0B3-00A024C79287}", "sIBL", false));
	}
	catch (error)
	{
	}
}

function passesEnvironmentShaderStackParametersDeletion()
{
	var passes = new ActiveXObject("XSI.Collection");
	passes.SetAsText("Passes.List.*");
	var passParameters = [];
	for(var i = 0; i < passes.count; i++)
	{
		environmentShaderStack = passes.item(i).NestedObjects("EnvironmentShaderStack");
		for(var j = environmentShaderStack.Parameters.Count - 1; j >= 0; j--)
		{
			if(environmentShaderStack.Parameters.item(j).Sources.Count == 0)
				environmentShaderStack.Remove( j );
		}
	}
}

function getEnvironmentShaderBranch(pass, inputShader, imageSource, connectionPorts, name)
{
	var lookupSphericalShader = CreateShaderFromProgID("mentalray.mib_lookup_spherical.1.0", pass);
	SIConnectShaderToCnxPoint(imageSource, lookupSphericalShader.tex, false);

	var colorMathBasicShader = CreateShaderFromProgID("Softimage.sib_color_math_basic.1.0", pass);
	colorMathBasicShader.Parameters("op").value = 2;
	SIConnectShaderToCnxPoint(lookupSphericalShader, colorMathBasicShader + ".input1", false);

	var color_Math_ExponentShader = CreateShaderFromProgID("Softimage.sib_color_math_exponent.1.0", pass);
	SIConnectShaderToCnxPoint(colorMathBasicShader, color_Math_ExponentShader + ".input", false);

	var colorMathBasicGammaShader = CreateShaderFromProgID("Softimage.sib_color_math_basic.1.0", pass);
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		colorMathBasicGammaShader.Parameters("input1").Parameters(subComponents[i]).value = 1;
	colorMathBasicGammaShader.Parameters("op").value = 3;
	SIConnectShaderToCnxPoint(colorMathBasicGammaShader, color_Math_ExponentShader + ".factor", false);

	var colorSwitchShader = CreateShaderFromProgID("Softimage.sib_color_switch.1.0", pass);
	for(var i = 0; i < subComponents.length; i++)
		colorSwitchShader.Parameters("input2").Parameters(subComponents[i]).value = 0;
	SIConnectShaderToCnxPoint(color_Math_ExponentShader, colorSwitchShader + ".input1", false);

	for(var i = 0; i < connectionPorts.length; i++)
		SIConnectShaderToCnxPoint(colorSwitchShader, inputShader + "." + connectionPorts[i], false);

	colorMathBasicShader.Parameters("name").value = name + "_Color_Math_Basic";
	color_Math_ExponentShader.Parameters("name").value = name + "_Color_Math_Exponent";
	colorMathBasicGammaShader.Parameters("name").value = name + "_Gamma_Color_Math_Basic";
	colorSwitchShader.Parameters("name").value = name + "_Color_Switch";
	lookupSphericalShader.Parameters("name").value = name + "_Mib_Lookup_Spherical";
}

function update_environmentShaders(createBackground, createLighting, createReflection, backgroundFilePath, lightingFilePath, reflectionFilePath, passes, overrideTweaks)
{
	var pass = passes[0];

	var raytype = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Raytype", true);
	raytype = raytype(0);

	var subComponents = ["red", "green", "blue"];

	if(raytype != null)
	{
		var ports = ["eye"];
		if(createBackground)
		{
			var backgroundSource = getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL_Background_Clip", true);
			if(backgroundSource != 0)
			{
				backgroundSource = backgroundSource(0);
				backgroundSource.Source.Parameters("FileName").Value = backgroundFilePath;
			}
			else
			{
				backgroundSource = Application.CreateImageClip2(backgroundFilePath, "sIBL_Background_Clip");
			}

			var backgroundLookupSphericalShader = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Background_Mib_Lookup_Spherical", true);
			if(backgroundLookupSphericalShader == 0)
				getEnvironmentShaderBranch(pass, raytype, backgroundSource, ports, "sIBL_Background");
		}
		else
		{
			if(overrideTweaks)
			{
				for(var j = 0; j < subComponents.length; j++)
					raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
			}
		}

		ports = ["fg", "photon"];
		if(createLighting)
		{
			var lightingSource = getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL_Lighting_Clip", true);
			if(lightingSource != 0)
			{
				lightingSource = lightingSource(0);
				lightingSource.Source.Parameters("FileName").Value = lightingFilePath;
			}
			else
			{
				lightingSource = Application.CreateImageClip2(lightingFilePath, "sIBL_Lighting_Clip");
			}

			var lightingLookupSphericalShader = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Lighting_Mib_Lookup_Spherical", true);
			if(lightingLookupSphericalShader == 0)
				getEnvironmentShaderBranch(pass, raytype, lightingSource, ports, "sIBL_Lighting");
		}
		else
		{
			if(overrideTweaks)
			{
				for(var i = 0; i < ports.length; i++)
				{
					for(var j = 0; j < subComponents.length; j++)
						raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
				}
			}
		}

		ports = ["reflection", "refraction"];
		if(createReflection)
		{
			var reflectionSource = getMatchingObjectsByClassID("{22C3E8F8-CCEA-11D2-B35B-00105A1E70DE}", "sIBL_Reflection_Clip", true);
			if(reflectionSource != 0)
			{
				reflectionSource = reflectionSource(0);
				reflectionSource.Source.Parameters("FileName").Value = reflectionFilePath;
			}
			else
			{
				reflectionSource = Application.CreateImageClip2(reflectionFilePath, "sIBL_Reflection_Clip");
			}

			var reflectionLookupSphericalShader = getMatchingObjectsByClassID("{6495C5C1-FD18-474E-9703-AEA66631F7A7}", "sIBL_Reflection_Mib_Lookup_Spherical", true);
			if(reflectionLookupSphericalShader == 0)
				getEnvironmentShaderBranch(pass, raytype, reflectionSource, ports, "sIBL_Reflection");
		}
		else
		{
			if(overrideTweaks)
			{
				for(var i = 0; i < ports.length; i++)
				{
					for(var j = 0; j < subComponents.length; j++)
						raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
				}
			}
		}

		// Connecting The Raytype Shader To Passes.
		for(var i = 0; i < passes.length; i++)
			SIConnectShaderToCnxPoint(raytype , passes[i] + ".EnvironmentShaderStack", false);
	}
	else
	{
		LogMessage("sIBL_GUI | No sIBL_Raytype found, skipping environment related Shaders updates!", siWarning);
	}
}

function getEnvironmentShaders(createBackground, createLighting, createReflection, backgroundFilePath, lightingFilePath, reflectionFilePath, passes)
{
	var pass = passes[0];

	var raytype = CreateShaderFromProgID("Softimage.sib_color_rayswitch.1.0", pass);
	var subComponents = ["red", "green", "blue"];
	raytype.Parameters("enable_fg").value = 1;
	for(var i = 0; i < subComponents.length; i++)
		raytype.Parameters("shadow").Parameters(subComponents[i]).value = 0;
	SIConnectShaderToCnxPoint(raytype , pass + ".EnvironmentShaderStack", false);

	var ports = ["eye", "refraction"];
	if(createBackground)
	{
		var backgroundSource = Application.CreateImageClip2(backgroundFilePath, "sIBL_Background_Clip");
		getEnvironmentShaderBranch(pass, raytype, backgroundSource, ports, "sIBL_Background");
	}
	else
	{
		for(var i = 0; i < ports.length; i++)
		{
			for(var j = 0; j < subComponents.length; j++)
				raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
		}
	}

	ports = ["fg", "photon"];
	if(createLighting)
	{
		var lightingSource = Application.CreateImageClip2(lightingFilePath, "sIBL_Lighting_Clip");
		getEnvironmentShaderBranch(pass, raytype, lightingSource, ports, "sIBL_Lighting");
	}
	else
	{
		for(var i = 0; i < ports.length; i++)
		{
			for(var j = 0; j < subComponents.length; j++)
				raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
		}
	}

	ports = ["reflection"];
	if(createReflection)
	{
		var reflectionSource = Application.CreateImageClip2(reflectionFilePath, "sIBL_Reflection_Clip");
		getEnvironmentShaderBranch(pass, raytype, reflectionSource, ports, "sIBL_Reflection");
	}
	else
	{
		for(var i = 0; i < ports.length; i++)
		{
			for(var j = 0; j < subComponents.length; j++)
				raytype.Parameters(ports[i]).Parameters(subComponents[j]).value = 0;
		}
	}

	// Connecting The Raytype Shader To Others Passes.
	for(var i = 1; i < passes.length; i++)
		SIConnectShaderToCnxPoint(raytype , passes[i] + ".EnvironmentShaderStack", false);

	raytype.Parameters("name").value = "sIBL_Raytype";
}

function getSIBLControls(controlsGroup)
{
	var controls_customProperty = controlsGroup.AddCustomProperty("Smart_IBL_Controls", false);

	// Render Togglers Parameters.
	controls_customProperty.AddParameter3("Background_Toggle", siBool, true);
	controls_customProperty.AddParameter3("Reflection_Toggle", siBool, true);
	controls_customProperty.AddParameter3("Lighting_Toggle", siBool, true);

	var slots = ["Background", "Reflection", "Lighting"];
	var components = ["Gamma", "Gain"];

	for(var i = 0; i < slots.length; i++)
	{
		for(var j = 0; j < components.length; j++)
			controls_customProperty.AddParameter3(slots[i] + "_" + components[j], siFloat, 1, 0, 10);
	}

	var controls_customProperty_layout = controls_customProperty.PPGLayout;

	controls_customProperty_layout.AddGroup("Render Togglers");
	controls_customProperty_layout.AddItem("Background_Toggle", "Background");
	controls_customProperty_layout.AddItem("Reflection_Toggle", "Reflection");
	controls_customProperty_layout.AddItem("Lighting_Toggle", "Lighting");
	controls_customProperty_layout.EndGroup();

	for(var i = 0; i < slots.length; i++)
	{
		controls_customProperty_layout.AddGroup(slots[i] + " Color Correction");
		for(var j = 0; j < components.length; j++)
			controls_customProperty_layout.AddItem(slots[i] + "_" + components[j], components[j]);
		controls_customProperty_layout.EndGroup();
	}
}

function getControlsGroup()
{
	var controlsGroup = Application.ActiveSceneRoot.FindChild("sIBL");

	if(controlsGroup == null)
	{
		var null_ = ActiveSceneRoot.AddPrimitive("Null", "helperNull");
		var controlsGroup = Application.CreateTransformGroup("sIBL", "B:" + null_);

		var locks = ["sclx", "scly", "sclz", "rotx", "roty", "rotz", "posx", "posy", "posz"];
		var globalKinematics = controlsGroup.Kinematics.Global.Parameters;
		for(var i = 0; i < locks.length; i++)
			globalKinematics(locks[i]).SetLock(siLockLevelManipulation);

		localKinematics = controlsGroup.Kinematics.Local.Parameters;
		for(var i = 0; i < locks.length; i++)
			localKinematics(locks[i]).SetLock(siLockLevelManipulation);

		DeleteObj(null_);

		getSIBLControls(controlsGroup)
	}

	return controlsGroup
}

function getFeedbackGeometry(feedbackRadius, displayFeedback)
{
	var feedback = ActiveSceneRoot.AddGeometry("Sphere", "NurbsSurface", "sIBL_Feedback");
	feedback.properties("visibility").Parameters("rendvis").value = 0;

	if(!displayFeedback)
		feedback.properties("visibility").Parameters("viewvis").value = 0;

	CreateProjection(feedback, siTxtUV, siTxtDefaultPlanarXY, null, "sIBL_Texture_Projection");

	var globalKinematics = feedback.Kinematics.Global.Parameters;
	globalKinematics("sclx").value = -globalKinematics("sclx").value;
	ResetTransform(feedback, siCtr, siSRT, siXYZ);
	globalKinematics("sclx").value = feedbackRadius;
	globalKinematics("scly").value = feedbackRadius;
	globalKinematics("sclz").value = feedbackRadius;

	ApplyTopoOp("Inverse", feedback, 3, siImmediateOperation);

	var locks = ["rotx", "rotz", "posx", "posy", "posz"];
	for(var i = 0; i < locks.length; i++)
	{
		globalKinematics(locks[i]).SetLock(siLockLevelManipulation);
	}

	localKinematics = feedback.Kinematics.Local.Parameters;

	for(var i = 0; i < locks.length; i++)
	{
		localKinematics(locks[i]).SetLock(siLockLevelManipulation);
	}

	addToDisplayLayer("sIBL_Feedback_Layer", feedback);

	return feedback;
}

function update_feedback(feedbackRadius, createBackground, displayFeedback)
{
	var feedback = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_Feedback", true);

	if(feedback == 0 && overrideTweaks)
	{
		getFeedback(feedbackRadius, createBackground, displayFeedback);
	}
	else
	{
		feedback = feedback(0);
		if(feedback != null)
		{
			var globalKinematics = feedback.Kinematics.Global.Parameters;
			globalKinematics("roty").value = 0;

			//Not Working After The Feedback Has Been Frozen.
			//globalKinematics("sclx").value = -feedbackRadius;
			//globalKinematics("scly").value = feedbackRadius;
			//globalKinematics("sclz").value = feedbackRadius;

			if(!displayFeedback)
				feedback.properties("visibility").Parameters("viewvis").value = 0;
			else
				feedback.properties("visibility").Parameters("viewvis").value = 1;
		}
		else
		{
			LogMessage("sIBL_GUI | No Feedback found, skipping Feedback related updates!", siWarning);
		}
	}
}

function getFeedback(feedbackRadius, createBackground, displayFeedback)
{
	var controlsGroup = getControlsGroup();
	var feedback = getFeedbackGeometry(feedbackRadius, displayFeedback);

	controlsGroup.AddChild(feedback);

	var feedbackMaterial = SICreateMaterial("Shaders/Material/Constant.Preset", "sIBL_Feedback_Material", null, null, false);

	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		feedbackMaterial.Parameters("Surface").NestedObjects(0).Parameters("transparency").Parameters(subComponents[i]).value = 0.5;

	AssignMaterial(feedbackMaterial + "," + feedback);
	if(createBackground)
		SIConnectShaderToCnxPoint("Clips.sIBL_Background_Clip", feedbackMaterial + ".sIBL_Feedback_Material.color");

	return feedback
}

function update_lightsConstraints(light, scale, uCoordinate, vCoordinate)
{
	var globalKinematics = light.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = scale;

	var constraints = light.Kinematics.Constraints;

	for(var k = 0; k < constraints.Count; k++)
	{
		var constraint = constraints(k);
		if(constraint.Type == "surfcns")
		{
			// U -> V & V -> U Because Of The Invert Normal.
			constraint.Parameters("posu").Value = 0.5 + (0.5 - vCoordinate);
			constraint.Parameters("posv").Value = uCoordinate;
		}
		if(constraint.Type == "dircns")
		{
			constraint.Parameters("dirx").Value = 0;
			constraint.Parameters("dirz").Value = -1;
			constraint.Parameters("upvct_active").Value = 1;
		}
	}
}

function update_sun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius, overrideTweaks)
{
	var sun = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_Sun", true);

	if(sun == 0 && overrideTweaks)
	{
		if(objectExists("sIBL_Feedback"))
		{
			getSun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius, physicalSun);
		}
	}
	else
	{
		sun = sun(0);
		if(sun != null)
		{
			update_lightsConstraints(sun, feedbackRadius / 15, sunU, sunV)
		}
		else
		{
			LogMessage("sIBL_GUI | No Sun found, skipping Sun related updates!", siWarning);
		}
	}
}function update_dynamicsLights(dynamicLightsType, dynamicLights, feedbackRadius)
{
	var sceneDynamicLights = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_DKL_", false);

	if(sceneDynamicLights == 0 && overrideTweaks)
	{
		if(objectExists("sIBL_Feedback"))
		{
			getDynamicLights(dynamicLightsType, dynamicLights, feedbackRadius);
		}
	}
	else
	{
		var dynamicLights = dynamicLights.split("|");

		for(var i = 0; i < sceneDynamicLights.Count; i++)
		{
			for(var j = 0; j < dynamicLights.length; j += 8)
			{
				var regexPattern = new RegExp(dynamicLights[j + 1].replace(/\s/g, "_"));

				if(sceneDynamicLights(i).name.match(regexPattern))
				{
					update_lightsConstraints(sceneDynamicLights(i), feedbackRadius / 15, dynamicLights[j + 6], dynamicLights[j + 7])
				}
			}
		}
	}
}

function getLight(parent, constraintParent, type, name, scale, physicalSun, intensity, color, uCoordinate, vCoordinate)
{
	switch(type)
	{
		case "Infinite":
			var primitiveType = "Infinite";
			break;
		case "Light Box":
			var primitiveType = "Light_Box";
			break;
		case "Point":
			var primitiveType = "Point";
			break;
		case "Spot":
			var primitiveType = "Spot";
			break;
	}

	var light = ActiveSceneRoot.AddPrimitive(primitiveType + ".Preset", name);
	parent.AddChild(light);

	var globalKinematics = light.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = scale;

	if(physicalSun && primitiveType == "Infinite")
	{
		physicalSunShader = CreateShaderFromProgID("mentalray.mia_physicalsun.1.0", light + ".light");
		SIConnectShaderToCnxPoint(physicalSunShader, light + ".light.LightShader", false);
		SIConnectShaderToCnxPoint(physicalSunShader, light + ".light.PhotonShader", false);
		physicalSunShader.Parameters("multiplier").value = intensity / 6.5;

		DisconnectAndDeleteOrUnnestShaders(light + ".light.soft_light", light + ".light");
	}
	else
	{
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("intensity").value = intensity;
		var subComponents = ["red", "green", "blue"];
		for(var i = 0; i < subComponents.length; i++)
			light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("color").Parameters(subComponents[i]).value = color[i] / 255;
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("factor").value = 0;
		light.Primitives("light").Parameters("LightShader").NestedObjects(0).Parameters("shadow").value = true;
	}

	switch(type)
	{
		case "Distant":
			break;
		case "Point":
			break;
		case "Quad":
			var subComponents = ["SX", "SY", "SZ"];
			for(var i = 0; i < subComponents.length; i++)
				light.Primitives("light").Parameters("LightAreaXform" + subComponents[i]).value = 1;
			break;
		case "Spot":
			break;
	}

	var surfaceConstraint = ApplyCns("Surface", light, constraintParent);

	if(objectExists("sIBL_Lights_Target"))
	{
		var lightTarget = Application.ActiveSceneRoot.FindChild("sIBL_Lights_Target");
	}
	else
	{
		var lightTarget = ActiveSceneRoot.AddPrimitive("Null", "sIBL_Lights_Target");
	}

	parent.AddChild(lightTarget)

	var directionConstraint = ApplyCns("Direction", light, lightTarget);

	var constraints = light.Kinematics.Constraints;
	for(var i = 0; i < constraints.Count; i++)
	{
		var constraint = constraints(i);
		if(constraint.Type == "surfcns")
		{
			// U -> V & V -> U Because Of The Invert Normal.
			constraint.Parameters("posu").Value = 0.5 + (0.5 - vCoordinate);
			constraint.Parameters("posv").Value = uCoordinate;
		}
		if(constraint.Type == "dircns")
		{
			constraint.Parameters("dirx").Value = 0;
			constraint.Parameters("dirz").Value = -1;
		}
	}

	addToDisplayLayer("sIBL_Lighting_Layer", lightTarget);

	addToDisplayLayer("sIBL_Lighting_Layer", light);
}

function getSun(sunLightType, sunU, sunV, sunColor, sunMultiplier, feedbackRadius, physicalSun)
{
	var controlsGroup = getControlsGroup();
	var feedback = Application.ActiveSceneRoot.FindChild("sIBL_Feedback");

	getLight(controlsGroup, feedback, sunLightType, "sIBL_Sun", feedbackRadius / 10, physicalSun, sunMultiplier, sunColor, sunU, sunV)
}

function getDynamicLights(dynamicLightsType, dynamicLights, feedbackRadius)
{
	var controlsGroup = getControlsGroup();
	var feedback = Application.ActiveSceneRoot.FindChild("sIBL_Feedback");
	var dynamicLights = dynamicLights.split("|");
	for(var i = 0; i < dynamicLights.length; i += 8)
		getLight(controlsGroup, feedback, dynamicLightsType, "sIBL_DKL_" + dynamicLights[i + 1], feedbackRadius / 15, false, parseFloat(dynamicLights[i + 5]), [parseFloat(dynamicLights[i + 2]), parseFloat(dynamicLights[i + 3]), parseFloat(dynamicLights[i + 4])], parseFloat(dynamicLights[i + 6]), parseFloat(dynamicLights[i + 7]))
}

function bridgeControlsAndShaders(pass, slot)
{
	AddExpr(pass + ".sIBL_" + slot + "_Color_Switch.switch", "1-(sIBL.Smart_IBL_Controls." + slot + "_Toggle)", true);

	var components = ["red", "green", "blue"];
	for(var i = 0; i < components.length; i++)
	{
		AddExpr(pass + ".sIBL_" + slot + "_Color_Math_Basic.input2." + components[i], "sIBL.Smart_IBL_Controls." + slot + "_Gain", true);
		AddExpr(pass + ".sIBL_" + slot + "_Gamma_Color_Math_Basic.input2." + components[i], "sIBL.Smart_IBL_Controls." + slot + "_Gamma", true);
	}
}

function connectFeedbackToShaders(feedback, connectToBackground, connectToLighting, connectToReflection, passes)
{
	var pass = passes[0];

	if(connectToBackground)
	{
		SetExpr(pass + ".sIBL_Background_Mib_Lookup_Spherical.rotate", "(" + feedback + ".kine.global.roty / 2 )  * PI / 180 + ( 67.5 * PI / 180 )");
		bridgeControlsAndShaders(pass, "Background");
	}

	if(connectToLighting)
	{
		SetExpr(pass + ".sIBL_Lighting_Mib_Lookup_Spherical.rotate", "(" + feedback + ".kine.global.roty / 2 )  * PI / 180 + ( 67.5 * PI / 180 )");
		bridgeControlsAndShaders(pass, "Lighting");
	}

	if(connectToReflection)
	{
		SetExpr(pass + ".sIBL_Reflection_Mib_Lookup_Spherical.rotate", "(" + feedback + ".kine.global.roty / 2 )  * PI / 180 + ( 67.5 * PI / 180 )");
		bridgeControlsAndShaders(pass, "Reflection");
	}
}

function setRenderer()
{
	SetValue("Passes.RenderOptions.Renderer", "mental ray");
}

function activateFinalGather(passes)
{
	var subComponents = ["red", "green", "blue"];
	for(var i = 0; i < subComponents.length; i++)
		ActiveSceneRoot.Properties.Item("Ambient Lighting").Parameters("ambience").Parameters(subComponents[i]).value = 0;

	SetValue("Views.ViewA.RenderRegion.mentalray.FGEnable,Views.ViewB.RenderRegion.mentalray.FGEnable,Views.ViewC.RenderRegion.mentalray.FGEnable,Views.ViewD.RenderRegion.mentalray.FGEnable", Array(true, true, true, true));

	for(var i = 0; i < passes.length; i++)
	{
		var pass = Dictionary.GetObject(passes[i]);
		pass.Properties("mental ray").Parameters("FGEnable").value = true;
	}
}

function activateSceneColorManagement(createBackground, passes)
{
	Application.Preferences.SetPreferenceValue("Display.color_management_source", 0);
	Application.Preferences.SetPreferenceValue("Display.color_management_render_region", true);
	Application.Preferences.SetPreferenceValue("Display.color_management_render_preview", true);
	Application.Preferences.SetPreferenceValue("Display.color_management_shader_balls", true);
	Application.Preferences.SetPreferenceValue("Display.color_management_ui_colors", true);

	for(var i = 0; i < passes.length; i++)
	{
		var pass = Dictionary.GetObject(passes[i]);
		pass.Parameters("UseDisplayGammaCorrection").value = true;
	}

	// Adjust Background Gamma Color Because Of The Color Management.
	if(createBackground)
	{
		var Smart_IBL_Controls_Property = getRequestedPropertiesAsCollection("Smart_IBL_Controls");
		Smart_IBL_Controls_Property.item(0).Background_Gamma.value = 1 / 2.2;
	}
}

function update_ground(feedbackRadius, shadowCatcher, overrideTweaks)
{
	var ground = getMatchingObjectsByClassID("{5FC0CCAE-3DC8-11D0-9449-00AA006D3165}", "sIBL_Ground", true);
	if(ground == 0 && overrideTweaks)
		getGround(feedbackRadius, shadowCatcher);
}

function getGround(feedbackRadius, shadowCatcher)
{
	var controlsGroup = getControlsGroup();

	var ground = ActiveSceneRoot.AddGeometry("Grid", "MeshSurface", "sIBL_Ground");
	controlsGroup.AddChild(ground)

	var globalKinematics = ground.Kinematics.Global.Parameters;
	var subComponents = ["sclx", "scly", "sclz"];
	for(var i = 0; i < subComponents.length; i++)
		globalKinematics(subComponents[i]).value = (feedbackRadius * Math.sqrt(2)) / 2;

	ResetTransform(ground, siCtr, siSRT, siXYZ);

	if(shadowCatcher)
	{
		var groundMaterial = SICreateMaterial("Shaders/Material/mental images/mip_Matte_Shadow.Preset", "sIBL_Ground_Material", null, null, false);

		var constantShader = CreateShaderFromProgID("Softimage.material-constant.1.0", groundMaterial);

		var subComponents = ["red", "green", "blue"];
		for(var i = 0; i < subComponents.length; i++)
			constantShader.Parameters("transparency").Parameters(subComponents[i]).value = 1;

		constantShader.Parameters("Name").value = "sIBL_Ground_Constant";

		SIConnectShaderToCnxPoint(constantShader, groundMaterial + ".sIBL_Ground_Material.background");

		AssignMaterial(groundMaterial + "," + ground);
	}

	addToDisplayLayer("sIBL_Ground_Layer", ground);
}

function objectExists(object)
{
	var seekedObject = Application.ActiveSceneRoot.FindChild(object);
	if(seekedObject != null)
		return true
	else
		return false
}

function commandExists(command)
{
	var commands = Application.Commands;

	var e = new Enumerator(commands)
	for( ; !e.atEnd(); e.moveNext() )
	{
		if(e.item() == command)
			return true
	}

	return false
}

function addToDisplayLayer(layerName, object)
{
	var sceneLayers = ActiveProject.ActiveScene.Layers;
	var layerExists = false;

	for(var i = 0; i < sceneLayers.Count; i++)
	{
		if(sceneLayers(i).name == layerName)
		{
			layerExists = true;
			break;
		}
	}

	if(!layerExists)
		CreateLayer(null, layerName, object);
	else
		MoveToLayer("Layers." + layerName, object);
}

function getSceneExtent()
{
	var meshes = getMatchingObjectsByClassID("{400CCE36-4400-11D0-BDDD-00A0241981E2}", ".*", false)
	var surfaces = getMatchingObjectsByClassID("{28DEC312-62B3-11D1-B79B-00A0243E3694}", ".*", false)
	var pointClouds = getMatchingObjectsByClassID("{2194FFE3-A0B2-4CAB-A3E8-FC8EDC9F159A}", ".*", false)

	var objects = extendCollection(meshes, surfaces);
	objects = extendCollection(objects, pointClouds);

	var parents = new ActiveXObject("XSI.Collection");
	for(var i = 0; i < objects.Count; i++)
		parents.add(objects(i).Parent);

	var sceneBoundingBox = GetBBox(parents);
	sceneBoundingBox = [sceneBoundingBox.value( "LowerBoundX" ), sceneBoundingBox.value( "LowerBoundY" ), sceneBoundingBox.value( "LowerBoundZ" ), sceneBoundingBox.value( "UpperBoundX" ), sceneBoundingBox.value( "UpperBoundY" ), sceneBoundingBox.value( "UpperBoundZ" )];
	var sceneExtent = 0
	for(var i = 0; i < sceneBoundingBox.length; i++)
		if( Math.abs(sceneBoundingBox[i]) > sceneExtent )
			sceneExtent = Math.abs(sceneBoundingBox[i]);
	return sceneExtent;
}

function truncFloatNumber(number, truncValue)
{
	if(truncValue != 0)
		return Math.round(number / truncValue) * truncValue;
	else
		return number;
}

function getExtendedFeedbackRadius(feedbackRadius)
{
	var sceneExtent = getSceneExtent();
	sceneExtent = (sceneExtent + (sceneExtent*50/100))/4;

	if(sceneExtent < feedbackRadius)
		return feedbackRadius;
	else
		return truncFloatNumber(sceneExtent,10);
}

function scriptEditorVerbose(verboseState)
{
	Application.Preferences.SetPreferenceValue("scripting.cmdlog", verboseState);
	Application.Preferences.SetPreferenceValue("scripting.msglog", verboseState);
	Application.Preferences.SetPreferenceValue("scripting.msglogverbose", verboseState);
}

function autoInspectState(autoInspectState)
{
	Application.Preferences.SetPreferenceValue("Interaction.autoinspect", autoInspectState);
}

function getRequestedPropertiesAsCollection(propertyType)
{
	var properties = getByClassIDAsCollection("{76332571-D242-11d0-B69C-00AA003B3EA6}");

	if(properties.count != 0)
	{
		var propertiesListAsStringArray = getCollectionAsStringArray(properties);

		var regexPattern = new RegExp(propertyType + "\\w*");

		var requestedProperties = new Array();

		for(var i = 0; i < propertiesListAsStringArray.length; i++)
		{
			var propertyFound = propertiesListAsStringArray[i].match(regexPattern);

			if(propertyFound)
				requestedProperties[requestedProperties.length] = propertiesListAsStringArray[i];
		}

		var requestedPropertiesAsCollection = new ActiveXObject("XSI.Collection");

		if(requestedProperties.length != 0)
			requestedPropertiesAsCollection = getStringArrayAsCollection(requestedProperties);

		return requestedPropertiesAsCollection;
	}
	else
	{
		return 0;
	}
}

function deleteRequestedProperties(propertyType)
{
	var requestedProperties = getRequestedPropertiesAsCollection(propertyType);

	for(var i = 0; i < requestedProperties.count; i++)
		DeleteObj(requestedProperties.item(i));
}

function getByClassIDAsCollection(currentClassID)
{
	var nodesByClassID = new ActiveXObject("XSI.Collection");

	nodesByClassID = FindObjects(null, currentClassID);

	return nodesByClassID;
}

function getCollectionAsStringArray(currentCollection)
{
	var collectionObjectsAsString = currentCollection.GetAsText();
	var collectionObjects = collectionObjectsAsString.split(",");

	return collectionObjects;
}

function getStringArrayAsCollection(currentStringArray)
{
	var stringArrayAsCollection = new ActiveXObject("XSI.Collection");
	stringArrayAsCollection.SetAsText(currentStringArray);

	return stringArrayAsCollection;
}

function extendCollection(initialCollection, extensionCollection)
{
	for(var i = 0; i < extensionCollection.Count; i++)
		initialCollection.Add(extensionCollection(i));
	return initialCollection;
}

function getMatchingObjectsByClassID(classID, pattern, matchExact)
{
	var objectsByClassID = new ActiveXObject("XSI.Collection");
	objectsByClassID = FindObjects(null, classID);
	matchingObjects = new ActiveXObject("XSI.Collection");
	for(var i = 0; i < objectsByClassID.Count; i++)
	{
		if(matchExact)
		{
			if(objectsByClassID(i).name == pattern)
				matchingObjects.Add(objectsByClassID(i));
		}
		else
		{
			if(objectsByClassID(i).name.match(pattern))
				matchingObjects.Add(objectsByClassID(i));
		}
	}
	return matchingObjects;
}