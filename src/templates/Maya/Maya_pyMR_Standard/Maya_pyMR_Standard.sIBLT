[Template]
Name = @Name | Standard | String | Template Name
Path = @Path | | String | Template Path
HelpFile = @HelpFile | help/Maya_pyMR_Standard Template Manual.html | String | Help File
Release = @Release | 0.9.0 | String | Template Release
Date = @Date | 17 April 2011 | String | Date
Author = @Author | Kel Solaar | String | Author
Email = @Email | thomas.mansencal@gmail.com | String | Email
Url = @Url | http://thomasmansencal.com/ | String | Url
Software = @Software | Maya | String | Software
Version = @Version | 2011 | String | Version
Renderer = @Renderer | Mental Ray | String | Renderer
OutputScript = @OutputScript | sIBL_Maya_Import.py | String | Output Script
Comment = @Comment | This is Maya 2011 Mental Ray Template. | String | Comment

[Ibl Set Attributes]
Background|BGfile = @BGfile
Background|BGheight = @BGheight
Enviroment|EVfile = @EVfile
Enviroment|EVmulti = @EVmulti
Enviroment|EVgamma = @EVgamma
Reflection|REFfile = @REFfile
Reflection|REFmulti = @REFmulti
Reflection|REFgamma = @REFgamma
Sun|SUNu = @SUNu
Sun|SUNv = @SUNv
Sun|SUNcolor = @SUNcolor
Sun|SUNmulti = @SUNmulti
Header|Height = @Height
Header|North = @North
Lights|DynamicLights = @dynamicLights

[Common Attributes]
createBackground = @createBackground | 1 | Boolean | Create Background
createReflection = @createReflection | 1 | Boolean | Create Reflection
createLighting = @createLighting | 1 | Boolean | Create Lighting
createSun = @createSun | 1 | Boolean | Create Sun
createLights = @createLights | 1 | Boolean | Create Dynamic Lights

[Additional Attributes]
showCamerasDialog = @showCamerasDialog | 0 | Boolean | Cameras Selection Dialog
preserveSessionSettings = @preserveSessionSettings | 1 | Boolean | Preserve Session Settings
displayFeedback = @displayFeedback | 1 | Boolean | Display Feedback
sunLightType = @sunLightType | Directional;Area;Spot;Point | Enum | Sun Light Type
dynamicLightsType = @dynamicLightsType | Directional;Area;Spot;Point | Enum | Dynamic Lights Type
hideLights = @hideLights | 1 | Boolean | Hide Lights
createGround = @createGround | 1 | Boolean | Create Ground
shadowCatcher = @shadowCatcher | 1 | Boolean | Ground Shadow Catcher
physicalSun = @physicalSun | 1 | Boolean | Physical Sun
activateFinalGather = @activateFinalGather | 1 | Boolean | Activate Final Gather
activateLinearWorkflow = @activateLinearWorkflow | 1 | Boolean | Activate Linear Workflow
framebufferGamma = @framebufferGamma | 0 | Boolean | Use Framebuffer Gamma
photographicTonemapper = @photographicTonemapper | 0 | Boolean | Use Photographic Tonemapper

[Remote Connection]
ConnectionType = @ConnectionType | Socket | String | Connection Type
ExecutionCommand = @ExecutionCommand | python("import os;import sys;path = \"$loaderScriptPath\";directory = os.path.dirname(path);module = os.path.splitext(os.path.basename(path))[0];not directory in sys.path and sys.path.append(directory);import_ = __import__(module);reload(import_);sIBL_Setup = import_.Setup(); sIBL_Setup.execute()"); | String | ExecutionCommand
DefaultAddress = @DefaultAddress | 127.0.0.1 | Integer | Default Address
DefaultPort = @DefaultPort | 2048 | Integer | Default Port

[Script]
# @OutputScript - @Release For @Software @Version
# Author: @Author
# EMail: @Email
# Homepage: @Url
# Template Path: @Path
# Template Last Modified: @Date
# sIBL_GUI
import math
import maya.cmds as cmds
import maya.mel as mel
import os
import re
import sys

class Structure(object):
	def __init__(self, **kwargs):
		self.__dict__.update(kwargs)

class Light(Structure):
	pass

class Constants(object):
	applicationName = "sIBL_GUI"
	prefix = "sIBL"
	splitter = "_" 
	package = "@Software".replace(" ", "_")
	renderer = "@Renderer".replace(" ", "_")
	packagePrefix = "%s_%s" % (prefix, package)
	packageRendererPrefix = "%s_%s_%s" % (prefix, package, renderer)
	title = "Smart IBL"
	controlsTitle = "[ %s Controls ]" % title
	maximumViewportTextureSize = 8192
	sessionNodeTypes =  ("condition", 
						"displayLayer", 
						"expression", 
						"file", 
						"lambert", 
						"mentalrayTexture", 
						"mia_exposure_photographic", 
						"mia_exposure_simple", 
						"mia_physicalsun", 
						"mib_color_alpha", 
						"mib_lookup_spherical", 
						"mip_gamma_gain", 
						"mip_matteshadow", 
						"mip_rayswitch", 
						"place2dTexture", 
						"shadingEngine")

def getDynamicLights(datas):
	tokens = datas.split("|")
	dynamicLights = {}
	try:
		for i in range(0, len(tokens), 8):
			dynamicLights[tokens[i]] = Light(name=tokens[i+1], color=(tokens[i+2], tokens[i+3], tokens[i+4]), multiplier=tokens[i+5], uCoordinate=tokens[i+6], vCoordinate=tokens[i+7] )
	except:
		pass
	return dynamicLights

class Datas(object):
	backgroundFile = "@BGfile"
	backgroundWidth = @BGheight * 2
	reflectionFile = "@REFfile"
	reflectionMultiplier = @REFmulti
	reflectionGamma = @REFgamma
	lightingFile = "@EVfile"
	lightingMultiplier = @EVmulti
	lightingGamma = @EVgamma
	sunU = @SUNu
	sunV = @SUNv
	sunColor = [@SUNcolor]
	sunMultiplier = @SUNmulti
	dynamicLights = getDynamicLights("@dynamicLights")
	height = @Height
	north = @North

class Options(object):
	createBackground = @createBackground
	createReflection = @createReflection
	createLighting = @createLighting
	createSun = @createSun
	createLights = @createLights
	showCamerasDialog = @showCamerasDialog
	preserveSessionSettings = @preserveSessionSettings
	displayFeedback = @displayFeedback
	feedbackRadius = 100
	sunLightType = "@sunLightType"
	dynamicLightsType = "@dynamicLightsType"
	hideLights = @hideLights
	createGround = @createGround
	shadowCatcher = @shadowCatcher
	physicalSun = @physicalSun
	activateFinalGather = @activateFinalGather
	activateLinearWorkflow = @activateLinearWorkflow
	framebufferGamma = @framebufferGamma
	photographicTonemapper = @photographicTonemapper

class Setup(object):
	def __init__(self):
		if Datas.backgroundFile == "-1" or Datas.reflectionFile == "-1" or Datas.lightingFile == "-1":
			if cmds.confirmDialog(title="Confirm", message="%s | Non Template Compatible Ibl Set Provided: Unpredictable Results May Occur! Would You Like To Proceed Anyway?" % Constants.applicationName, button=["Yes", "No"], defaultButton="Yes", cancelButton="No", dismissString="No") == "No":
				mel.eval("warning(\"%s | %s\")" % (Constants.applicationName, "%s File Import Canceled!" % Constants.prefix))
				self.__exit__()

		cmds.optionVar(sv=("%s_outputCameras" % Constants.prefix, ""))
		self.outputCameras = cmds.ls(l=True, type="camera")
		self.feedbackRadius = Options.feedbackRadius
		self.storedSessionAttributes = {"%s%sfeedback.rotateX" % (Constants.prefix, Constants.splitter):0,
										"%s%sfeedback.scaleX" % (Constants.prefix, Constants.splitter):1,
										"%s%sfeedback.scaleY" % (Constants.prefix, Constants.splitter):1,
										"%s%sfeedback.scaleZ" % (Constants.prefix, Constants.splitter):1,
										"%s%sground.translateX" % (Constants.prefix, Constants.splitter):0,
										"%s%sground.translateY" % (Constants.prefix, Constants.splitter):0,
										"%s%sground.translateZ" % (Constants.prefix, Constants.splitter):0,
										"%s%sground.rotateX" % (Constants.prefix, Constants.splitter):0,
										"%s%sground.rotateY" % (Constants.prefix, Constants.splitter):0,
										"%s%sground.rotateZ" % (Constants.prefix, Constants.splitter):0,
										"%s%sground.scaleX" % (Constants.prefix, Constants.splitter):1,
										"%s%sground.scaleY" % (Constants.prefix, Constants.splitter):1,
										"%s%sground.scaleZ" % (Constants.prefix, Constants.splitter):1}

	def	__exit__(self):
		cmds.optionVar(remove=("%s_outputCameras" % Constants.prefix))
		sys.exit()

	def execute(self):
		if mel.eval("exists %s_preProcessCallback;" % Constants.packagePrefix):
			print("%s | Executing Overall Preprocess Callback!" % Constants.applicationName)
			mel.eval("%s_preProcessCallback();" % Constants.packagePrefix)

		if mel.eval("exists %s_preProcessCallback;" % Constants.packageRendererPrefix):
			print("%s | Executing Template Specific Preprocess Callback!" % Constants.applicationName)
			mel.eval("%s_preProcessCallback();" % Constants.packageRendererPrefix)

		print("%s | Starting sIBL File Import!" % Constants.applicationName)
		
		if Options.showCamerasDialog:
			if cmds.layoutDialog(t="%s Camera Chooser" % Constants.applicationName, ui=camerasChooser_formLayout) == "Cancel":
				mel.eval("warning(\"%s | %s\")" % (Constants.applicationName, "%s File Import Canceled!" % Constants.prefix))
				self.__exit__()
			self.outputCameras = cmds.optionVar(q="%s_outputCameras" % Constants.prefix) != "" and cmds.optionVar(q="%s_outputCameras" % Constants.prefix).split(",") or None
			if not self.outputCameras:
				mel.eval("warning(\"%s | %s\")" % (Constants.applicationName, "No Cameras Selected, %s File Import Canceled!" % Constants.prefix))
				self.__exit__()

		Options.preserveSessionSettings and self.storeSessionAttributes()
		
		self.setRenderer()
		self.deleteSession()

		self.outputCameras = filterNonExistingNodes(self.outputCameras)
		self.getExtendedFeedbackRadius()		
		
		self.getControlsLocator()
		Options.hideLights and self.hideLights()
		self.getEnvironmentShaders()
		self.getFeedback()			
			
		print Datas.__dict__.values()
		print Options.__dict__.values()
		
		print("%s | %s File Import Finished!" % (Constants.applicationName, Constants.prefix))
		
		self.__exit__()
	
	def storeSessionAttributes(self):
		for attribute in self.storedSessionAttributes.keys():
			if len(cmds.ls(attribute)):
				self.storedSessionAttributes[attribute]= cmds.getAttr(attribute)
	
	def restoreSessionAttributes(self):
		for attribute in self.storedSessionAttributes.keys():
			if len(cmds.ls(attribute)):
				cmds.setAttr(self.storedSessionAttributes[attribute])

	def deleteSession(self):
		if cmds.objExists(Constants.prefix):
			cmds.delete(Constants.prefix)
		
		for type in Constants.sessionNodeTypes:
			deleteType(type, "\\b%s*" % Constants.prefix)

	def getControlsGroup(self):
		controlsGroup = cmds.ls(Constants.prefix, fl=True)
		if not controlsGroup:
			controlsGroup = cmds.createNode("transform", n=Constants.prefix)
			lockAttributes(controlsGroup, ("tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"))
		return controlsGroup

	def getControlsLocator(self):
		controlsGroup = self.getControlsGroup()

		annotation = cmds.createNode("annotationShape")
		cmds.setAttr("%s.displayArrow" % annotation, 0)
		cmds.setAttr("%s.displayArrow" % annotation, lock=True, keyable=False)
		cmds.setAttr("%s.text" % annotation, Constants.controlsTitle, type="string")

		annotationTransform = getTransform(annotation)
		cmds.setAttr("%s.ty" % annotationTransform, 5)
		lockAttributes(annotationTransform, ("rx", "ry", "rz", "sx", "sy", "sz"))
		cmds.addAttr(annotationTransform, ln="renderTogglers", nn="[ Render Togglers ]", at="enum", en=Constants.title)
		cmds.setAttr("%s.renderTogglers" % annotationTransform, e=True, keyable=True, lock=True)

		components = ("Background", "Reflection", "Lighting")
		for component in components:
			cmds.addAttr(annotationTransform, ln="toggle%s" % component, nn=component, at="bool")
			cmds.setAttr("%s.toggle%s" % (annotationTransform, component), e=True, keyable=True, lock=False)
		
		controls = ("Gamma", "Gain")
		for component in components:
			cmds.addAttr(annotationTransform, ln="cc%s" % component, nn="[ %s CC ]" % component, at="enum", en=Constants.title)
			cmds.setAttr("%s.cc%s" % (annotationTransform, component), e=True, keyable=True, lock=True)
			for control in controls:
				cmds.addAttr(annotationTransform, ln="%s%s" % (component.lower(), control), nn="%s" % control, at="double")
				cmds.setAttr("%s.%s%s" % (annotationTransform, component.lower(), control), e=True, keyable=True, lock=False)
				cmds.setAttr("%s.%s%s" % (annotationTransform, component.lower(), control), 1.0)
	
		cmds.parent(cmds.rename(annotationTransform, "%s%scontrols" % (Constants.prefix, Constants.splitter)), controlsGroup)

	def getExtendedFeedbackRadius(self):
		sceneExtent = getSceneExtent() * math.sqrt(2)
		sceneExtent = sceneExtent + (sceneExtent * 10 / 100)
		
		if sceneExtent > self.feedbackRadius:
			self.feedbackRadius = truncFloat(sceneExtent, 10)

	def hideLights(self):
		lights = cmds.ls(lights=True)
		lights and cmds.hide(lights)

	def getEnvironmentShadersBranch(self, raySwitch, ports, file, prefix, useOverride):
		gammaGain = cmds.shadingNode("mip_gamma_gain", asUtility=True)

		if useOverride:
			condition = cmds.shadingNode("condition", asUtility=True)
			setAttributes({"%s.firstTerm" % condition:1, "%s.secondTerm" % condition:1})
			cmds.connectAttr("%s.outValue" % gammaGain, "%s.colorIfTrue" % condition, f=True)

			colorAlpha = cmds.shadingNode("mib_color_alpha", asUtility=True)
			cmds.setAttr("%s.factor" % colorAlpha, 0) 			
			cmds.connectAttr("%s.outValue" % colorAlpha, "%s.colorIfFalse" % condition, f=True)

			for port in ports:
				cmds.connectAttr("%s.outColor" % condition, "%s.%s" % (raySwitch, port), f=True)

			cmds.rename(condition, "%s%s%s" % (prefix, Constants.splitter, cmds.nodeType(condition)))
			cmds.rename(colorAlpha, "%s%s%s" % (prefix, Constants.splitter, cmds.nodeType(colorAlpha)))
		else:
			for port in ports:
				cmds.connectAttr("%s.outValue" % gammaGain, "%s.%s" % (raySwitch, port), f=True)
				cmds.connectAttr("%s.outValueA" % gammaGain, "%s.%sA" % (raySwitch, port), f=True)

		lookupSpherical = cmds.shadingNode("mib_lookup_spherical", asShader=True)

		cmds.connectAttr("%s.outValue" % lookupSpherical, "%s.input" % gammaGain, f=True)
		cmds.connectAttr("%s.outValueA" % lookupSpherical, "%s.inputA" % gammaGain, f=True)

		mentalrayTexture = cmds.shadingNode("mentalrayTexture", asTexture=True)
		cmds.connectAttr("%s.message" % mentalrayTexture, "%s.tex" % lookupSpherical, f=True)
		cmds.setAttr("%s.fileTextureName" % mentalrayTexture, file, type="string")

		for node in (gammaGain, lookupSpherical, mentalrayTexture):
			cmds.rename(node, "%s%s%s" % (prefix, Constants.splitter, cmds.nodeType(node)))

	def getEnvironmentShaders(self):
		raySwitch = cmds.shadingNode("mip_rayswitch", asUtility=True)
		
		if Options.createBackground:
			ports = ("eye", "transparent", "refraction")
			self.getEnvironmentShadersBranch(raySwitch, ports, Datas.backgroundFile,"%s%sbackground" % (Constants.prefix, Constants.splitter), 1)

		if Options.createLighting:
			ports = ("finalgather",)
			self.getEnvironmentShadersBranch(raySwitch, ports, Datas.lightingFile,"%s%slighting" % (Constants.prefix, Constants.splitter), 1)
	
		if Options.createReflection:
			ports = ("reflection", "environment")
			self.getEnvironmentShadersBranch(raySwitch, ports, Datas.reflectionFile,"%s%sreflection" % (Constants.prefix, Constants.splitter), 1)

		for camera in self.outputCameras:
			cmds.connectAttr("%s.message" % raySwitch, "%s.miEnvironmentShader" % camera, f=True)
		
		cmds.rename(raySwitch, "%s%s%s" % (Constants.prefix, Constants.splitter, cmds.nodeType(raySwitch)))

	def getDisplayLocator(self, name, radius, visibility):
		locator = cmds.sphere(name=name, ch=0)[0]
		cmds.rebuildSurface(locator, su=4, sv=8, ch=0)
		setAttributes({"%s.miDeriveFromMaya" % locator:0,
						"%s.visibility" % locator:visibility,
						"%s.miHide" % locator:1,
						"%s.scaleZ" % locator:-1})
		cmds.makeIdentity(locator, apply=True, t=0, r=0, s=1, n=0)
		setAttributes({"%s.rotateZ" % locator:90,
						"%s.scaleX" % locator:radius,
						"%s.scaleY" % locator:radius,
						"%s.scaleZ" % locator:radius})
		lockAttributes(locator, ("tx", "ty", "tz", "ry", "rz"))
		locatorShape = getShapes(locator)[0]
		setAttributes({"%s.doubleSided" % locatorShape:False,
						"%s.opposite" % locatorShape:False})	
		return locator

	def getFeedback(self):
		feedback = self.getDisplayLocator("%s%sfeedback" % (Constants.prefix, Constants.splitter), self.feedbackRadius, Options.displayFeedback)
		cmds.parent(feedback, self.getControlsGroup())
		addToDisplayLayer(feedback, "%s%sfeedback_layer" % (Constants.prefix, Constants.splitter))
		
		lambert = cmds.shadingNode("lambert", asShader=True)
		cmds.setAttr("%s.transparency" % lambert, 0.5, 0.5, 0.5, type="double3")
		shadingEngine = cmds.sets(renderable=True, noSurfaceShader=True, empty=True)		
		cmds.connectAttr("%s.outColor" % lambert, "%s.surfaceShader" % shadingEngine, f=True)
		
		file = cmds.shadingNode("file", asTexture=True)
		not cmds.ls("%s.resolution" % file) and cmds.addAttr(file, ln="resolution", at="long")
		cmds.setAttr("%s.resolution" % file, 2048)
		
		fileTextureName = Datas.backgroundFile
		if Datas.backgroundWidth > Constants.maximumViewportTextureSize:
			cmds.confirmDialog(title="%s | Information" % Constants.applicationName, message="The Background Image Is Too Large To Be Displayed On The Visual Feedback.\nCurrent Environment Image Width: %s Pixels.\nThe Visual Feedback Will Use The Reflection Image Instead." % Datas.backgroundWidth, button=("Ok",), defaultButton="Ok")
			fileTextureName = Datas.reflectionFile
		cmds.setAttr("%s.fileTextureName" % file, fileTextureName, type="string")
		cmds.connectAttr("%s.outColor" % file, "%s.color" % lambert, f=True)
		
		place2dTexture = cmds.shadingNode("place2dTexture", asUtility=True)
		cmds.connectAttr("%s.outUV" % place2dTexture, "%s.uvCoord" % file, f=True)
		cmds.connectAttr("%s.outUvFilterSize" % place2dTexture, "%s.uvFilterSize" % file, f=True)
		attributes = ("coverage", "translateFrame", "rotateFrame", "mirrorU", "mirrorV", "stagger", "wrapU", "wrapV" , "repeatUV" , "vertexUvOne" , "vertexUvTwo" , "vertexUvThree" , "vertexCameraOne", "noiseUV", "offset", "rotateUV")
		for attribute in attributes:
			cmds.connectAttr("%s.%s" % (place2dTexture, attribute), "%s.%s" % (file, attribute), f=True)		
		cmds.setAttr("%s.rotateFrame" % place2dTexture, 90)

		cmds.sets(feedback, e=True, forceElement=shadingEngine)

		for node in (lambert, shadingEngine, file, place2dTexture):
			cmds.rename(node, "%s%sfeedback_%s" % (Constants.prefix, Constants.splitter, cmds.nodeType(node)))

	def setRenderer(self):
		not cmds.pluginInfo("Mayatomr", q=True, loaded=True) and cmds.loadPlugin("Mayatomr")
		cmds.setAttr("defaultRenderGlobals.currentRenderer", "mentalRay", type="string")
		mel.eval("miCreateGlobalsNode;miCreateDefaultNodes;miCreateOtherOptionsNodesForURG;")

def camerasChooser_formLayout():
	camerasChooser_formLayout = cmds.setParent(q=True)
	cmds.formLayout(camerasChooser_formLayout, e=True, height=300)
	selectAll_button = cmds.button("%s_selectAll_button" % Constants.applicationName, label="Select All", command=selectAll_button_OnClicked)
	selectNone_button = cmds.button("%s_selectNone_button" % Constants.applicationName, label="Select None", command=selectNone_button_OnClicked)

	cameras_textScrollList = cmds.textScrollList("%s_cameras_textScrollList" % Constants.applicationName, allowMultiSelection=True, fn="smallFixedWidthFont",sc=cameras_textScrollList_OnSelectionChanged)

	for camera in cmds.ls(l=True, type="camera"):
		cmds.textScrollList("%s_cameras_textScrollList" % Constants.applicationName, e=True, append=camera)

	buttons_rowlayout = cmds.rowLayout(numberOfColumns=2, cl2=("center", "center"), ct2=("both", "both"))
	ok_button = cmds.button("%s_ok_button" % Constants.applicationName, label="Ok", command="cmds.layoutDialog(dismiss='Ok')")
	cancel_button = cmds.button("%s_cancel_button" % Constants.applicationName, label="Cancel", command="cmds.layoutDialog(dismiss='Cancel')")

	spacer = margin = 4
	cmds.formLayout(camerasChooser_formLayout, edit=True,
					attachForm = [(selectAll_button, "top", margin),
					(selectAll_button, "left", margin),
 					(selectAll_button, "right", margin),
					(selectNone_button, "left", margin),
 					(selectNone_button, "right", margin),
					(cameras_textScrollList, "right", margin),
 					(cameras_textScrollList, "left", margin),
					(buttons_rowlayout, "left", margin),
 					(buttons_rowlayout, "right", margin),
					(buttons_rowlayout, "bottom", margin)],
					attachControl=[(cameras_textScrollList, "top", spacer, selectNone_button),
					(selectNone_button, "top", spacer, selectAll_button),
					(cameras_textScrollList, "bottom", 	spacer, buttons_rowlayout)])

def selectAll_button_OnClicked(value):
	for i in range(1,cmds.textScrollList("%s_cameras_textScrollList" % Constants.applicationName, q=True, ni=True) + 1):
		cmds.textScrollList("%s_cameras_textScrollList" % Constants.applicationName, e=True, sii=i)

def selectNone_button_OnClicked(value):
	cmds.textScrollList("%s_cameras_textScrollList" % Constants.applicationName, e=True, da=True)

def cameras_textScrollList_OnSelectionChanged():
	cmds.optionVar(sv=("%s_outputCameras" % Constants.prefix, ",".join(cmds.textScrollList("%s_cameras_textScrollList" % Constants.applicationName, q=True, si=True))))

def setAttributes(attributes):
	for attribute, value in attributes.items():
		cmds.setAttr(attribute, value)

def lockAttributes(node, attributes):
	for attribute in attributes:
		cmds.setAttr("%s.%s" % (node, attribute), lock=True, keyable=False)

def getSceneExtent():
	geometries = cmds.ls(l=True, geometry=True)
	transforms = []
	for geometry in geometries:
		transforms.append(getTransform(geometry))

	sceneExtent = 0
	for transform in transforms:
		boundingBox = cmds.xform(transform, q=True, bb=True)
		for value in boundingBox:
			if math.fabs(value) > sceneExtent:
				sceneExtent = math.fabs(value)

	return sceneExtent

def	truncFloat(number, truncValue):
	if truncValue != 0:
		return math.trunc(number / truncValue) * truncValue
	else:
		return number

def getShapes(object, fullPath=False, noIntermediate=True):
	shapes = cmds.listRelatives(object, fullPath=fullPath, shapes=True, noIntermediate=noIntermediate)
	return shapes != None and shapes or []

def getTransform(shape, fullPath=True):
	transform = ""
	if cmds.nodeType(shape) != "transform":
		parents = cmds.listRelatives(shape, fullPath=fullPath, parent=True)
		transform = parents[0]
	return transform
	
def deleteType(type, pattern):
	nodes=cmds.ls(l=True, type=type)
	for node in nodes:
		if re.search(pattern, node):
			cmds.delete(node)

def getObject(object):
	try:
		return cmds.ls(object, fl=True)[0]
	except:
		pass

def addToDisplayLayer(object, displayLayer):
	layer = getObject(displayLayer)
	layer = not layer and cmds.createDisplayLayer(name=displayLayer) or layer
	cmds.editDisplayLayerMembers(layer, object, noRecurse=True)
		
def filterNonExistingNodes(nodes):
	return [node for node in nodes if cmds.objExists(node)]