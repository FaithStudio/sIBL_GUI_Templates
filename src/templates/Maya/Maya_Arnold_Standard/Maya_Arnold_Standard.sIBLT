[Template]
Name = @Name | Standard | String | Template Name
Path = @Path | | String | Template Path
HelpFile = @HelpFile | help/Maya_Arnold_Standard Template Manual.html | String | Help File
Release = @Release | 0.3.4 | String | Template Release
Date = @Date | 11 March 2011 | String | Date
Author = @Author | Kel Solaar | String | Author
Email = @Email | thomas.mansencal@gmail.com | String | Email
Url = @Url | http://www.thomasmansencal.com/ | String | Url
Software = @Software | Maya | String | Software
Version = @Version | 2011 | String | Version
Renderer = @Renderer | Arnold | String | Renderer
OutputScript = @OutputScript | sIBL_Maya_Import.mel | String | Output Script
Comment = @Comment | This is Maya 2011 Arnold Template. | String | Comment

[Ibl Set Attributes]
Background|BGfile = @BGfile
Background|BGheight = @BGheight
Enviroment|EVfile = @EVfile
Enviroment|EVmulti = @EVmulti
Enviroment|EVgamma = @EVgamma
Reflection|REFfile = @REFfile
Reflection|REFmulti = @REFmulti
Reflection|REFgamma = @REFgamma
Sun|SUNu = @SUNu
Sun|SUNv = @SUNv
Sun|SUNcolor = @SUNcolor
Sun|SUNmulti = @SUNmulti
Header|Height = @Height
Header|North = @North
Lights|DynamicLights = @dynamicLights

[Common Attributes]
createBackground = @createBackground | 1 | Boolean | Create Background
createReflection = @createReflection | 1 | Boolean | Create Reflection
createLighting = @createLighting | 1 | Boolean | Create Lighting
createSun = @createSun | 1 | Boolean | Create Sun
createLights = @createLights | 1 | Boolean | Create Dynamic Lights

[Additional Attributes]
preserveSessionSettings = @preserveSessionSettings | 1 | Boolean | Preserve Session Settings
displayFeedback = @displayFeedback | 1 | Boolean | Display Feedback
sunLightType = @sunLightType | Directional;Area;Spot;Point | Enum | Sun Light Type
dynamicLightsType = @dynamicLightsType | Directional;Area;Spot;Point | Enum | Dynamic Lights Type
hideLights = @hideLights | 1 | Boolean | Hide Lights
createGround = @createGround | 1 | Boolean | Create Ground
shadowCatcher = @shadowCatcher | 1 | Boolean | Ground Shadow Catcher
useLightingForGlossy = @useLightingForGlossy | 0 | Boolean | Use Lighting Image For Glossy
activateLinearWorkflow = @activateLinearWorkflow | 1 | Boolean | Activate Linear Workflow

[Remote Connection]
ConnectionType = @ConnectionType | Socket | String | Connection Type
ExecutionCommand = @ExecutionCommand | source "$loaderScriptPath"; | String | ExecutionCommand
DefaultAddress = @DefaultAddress | 127.0.0.1 | Integer | Default Address
DefaultPort = @DefaultPort | 2048 | Integer | Default Port

[Script]
// @OutputScript - @Release For @Software @Version
// Author: @Author
// EMail: @Email
// Homepage: @Url
// Template Path: @Path
// Template Last Modified: @Date
// sIBL_GUI
string $backgroundFilePath = "@BGfile";
int $backgroundWidth = @BGheight * 2;
string $reflectionFilePath = "@REFfile";
float $reflectionMultiplier = @REFmulti;
float $reflectionGamma = @REFgamma;
string $lightingFilePath = "@EVfile";
float $lightingMultiplier = @EVmulti;
float $lightingGamma = @EVgamma;
float $sunU = @SUNu;
float $sunV = @SUNv;
float $sunColor[] = {@SUNcolor};
float $sunMultiplier = @SUNmulti;
string $dynamicLights = "@dynamicLights";
float $height = @Height;
float $north = @North;
int $createBackground = @createBackground;
int $createReflection = @createReflection;
int $createLighting = @createLighting;
int $createSun = @createSun;
int $createLights = @createLights;
int $preserveSessionSettings = @preserveSessionSettings;
int $displayFeedback = @displayFeedback;
float $feedbackRadius = 100;
string $sunLightType = "@sunLightType";
string $dynamicLightsType = "@dynamicLightsType";
int $hideLights = @hideLights;
int $createGround = @createGround;
int $useLightingForGlossy = @useLightingForGlossy;
int $activateLinearWorkflow = @activateLinearWorkflow;

int $proceedSetup = 1;
if($backgroundFilePath == "-1" || $reflectionFilePath == "-1" || $lightingFilePath == "-1")
{
	if(`confirmDialog -title "Confirm" -message ("sIBL_GUI | Non Template Compatible Ibl Set Provided: Unpredictable Results May Occur! Would You Like To Proceed Anyway?") -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"` == "No")
		$proceedSetup = 0;
}
if($proceedSetup)
	sIBL_Maya_Arnold_setup($backgroundFilePath,
					$backgroundWidth,
					$reflectionFilePath,
					$reflectionMultiplier,
					$reflectionGamma,
					$lightingFilePath,
					$lightingMultiplier,
					$lightingGamma,
					$sunU,
					$sunV,
					$sunColor,
					$sunMultiplier,
					$dynamicLights,
					$height,
					$north,
					$createBackground,
					$createReflection,
					$createLighting,
					$createSun,
					$createLights,
					$preserveSessionSettings,
					$displayFeedback,
					$feedbackRadius,
					$sunLightType,
					$dynamicLightsType,				
					$hideLights,
					$createGround,
					$useLightingForGlossy,
					$activateLinearWorkflow);
else
	print("sIBL_GUI | sIBL File Import Aborted!\n");

global proc sIBL_Maya_Arnold_setup(string $backgroundFilePath,
						int $backgroundWidth,
						string $reflectionFilePath,
						float $reflectionMultiplier,
						float $reflectionGamma,
						string $lightingFilePath,
						float $lightingMultiplier,
						float $lightingGamma,
						float $sunU,
						float $sunV,
						float $sunColor[],
						float $sunMultiplier,
						string $dynamicLights,
						float $height,
						float $north,
						int $createBackground,
						int $createReflection,
						int $createLighting,
						int $createSun,
						int $createLights,
						int $preserveSessionSettings,
						int $displayFeedback,
						float $feedbackRadius,
						string $sunLightType,
						string $dynamicLightsType,
						int $hideLights,
						int $createGround,
						int $useLightingForGlossy,
						int $activateLinearWorkflow)
{
	if(`exists sIBL_Maya_preProcessCallback`)
	{
		print("sIBL_GUI | Executing Overall Preprocess Callback!\n");
		sIBL_Maya_preProcessCallback();
	}

	if(`exists sIBL_Maya_Arnold_preProcessCallback`)
	{
		print("sIBL_GUI | Executing Template Specific Preprocess Callback!\n");
		sIBL_Maya_Arnold_preProcessCallback();
	}

	print("sIBL_GUI | Starting sIBL File Import!\n");

	string $sessionPreservedAttributes[] = sIBL_Maya_Arnold_getSessionPreservedAttributes();
	string $sessionStoredAttributes[] = {};
	if($preserveSessionSettings)
		$sessionStoredAttributes = sIBL_Maya_Arnold_storeSessionAttributes($sessionPreservedAttributes);
	
	sIBL_Maya_Arnold_activateArnold();

	sIBL_Maya_Arnold_environmentDeletion();

	$feedbackRadius = sIBL_Maya_Arnold_getExtendedFeedbackRadius($feedbackRadius);
	if($preserveSessionSettings && $sessionStoredAttributes[2] == "sIBL_Feedback.scaleX" && $sessionStoredAttributes[4] == "sIBL_Feedback.scaleY" && $sessionStoredAttributes[6] == "sIBL_Feedback.scaleZ")
		$feedbackRadius = (float($sessionStoredAttributes[3]) + float($sessionStoredAttributes[5]) + float($sessionStoredAttributes[7])) / 3;
	
	sIBL_Maya_Arnold_getMainLocator();

	if($hideLights)
		sIBL_Maya_Arnold_hideLights();
	
	sIBL_Maya_Arnold_getEnvironmentShaders($createBackground, $createLighting, $createReflection, $backgroundFilePath, $lightingFilePath, $reflectionFilePath, $displayFeedback, $useLightingForGlossy);

	if($backgroundWidth > 8192)
	{
		confirmDialog -title "sIBL_GUI | Information" -message ("The Background Image Is Too Large To Be Displayed On The Visual Feedback.\nCurrent Environment Image Width: " +  $backgroundWidth + " Pixels.\nThe Visual Feedback Will Use The Reflection Image Instead.")  -button "Ok" -defaultButton "Ok";
		sIBL_Maya_Arnold_getFeedback($reflectionFilePath, $feedbackRadius, $displayFeedback);
	}
	else
	{
		sIBL_Maya_Arnold_getFeedback($backgroundFilePath, $feedbackRadius, $displayFeedback);
	}

	if(sIBL_Maya_Arnold_objectExists("sIBL_Feedback", "sIBL_GUI | No Feedback Found, Aborting!\n"))
	{
		if($sunU != -1 && $sunV != -1)
		{
			if($createSun)
			{
				sIBL_Maya_Arnold_getSun($sunLightType, $sunU, $sunV, $sunColor, $sunMultiplier, $feedbackRadius);
			}
		}

		if($dynamicLights != -1)
		{
			if($createLights)
			{
				sIBL_Maya_Arnold_getDynamicLights($dynamicLightsType, $dynamicLights, $feedbackRadius);
			}
		}
	}

	string $feedback = sIBL_Maya_Arnold_getObject("sIBL_Feedback");
	sIBL_Maya_Arnold_connectFeedbackToSIBLShaders($feedback, $createBackground, $createLighting, $createReflection);

	if($createGround)
		sIBL_Maya_Arnold_getGround($feedbackRadius);

	if($activateLinearWorkflow)
		sIBL_Maya_Arnold_activateLinearWorkflow($createBackground);
			
	if($preserveSessionSettings)
		sIBL_Maya_Arnold_restoreSessionAttributes($sessionStoredAttributes);
			
	print("sIBL_GUI | sIBL File Import Finished!\n");

	if(`exists sIBL_Maya_postProcessCallback`)
	{
		print("sIBL_GUI | Executing Overall Postprocess Callback!\n");
		sIBL_Maya_postProcessCallback();
	}

	if(`exists sIBL_Maya_Arnold_postProcessCallback`)
	{
		print("sIBL_GUI | Executing Template Specific Postprocess Callback!\n");
		sIBL_Maya_Arnold_postProcessCallback();
	}
}

global proc string[] sIBL_Maya_Arnold_getSessionPreservedAttributes()
{
	string $sessionPreservedAttributes[] = {"sIBL_Feedback.rotateX",
						"sIBL_Feedback.scaleX",
						"sIBL_Feedback.scaleY",
						"sIBL_Feedback.scaleZ",
						"sIBL_Ground.translateX",
						"sIBL_Ground.translateY",
						"sIBL_Ground.translateZ",
						"sIBL_Ground.rotateX",
						"sIBL_Ground.rotateY",
						"sIBL_Ground.rotateZ",
						"sIBL_Ground.scaleX",
						"sIBL_Ground.scaleY",
						"sIBL_Ground.scaleZ",
						"sIBL_Ground.scaleE"
						};
	return $sessionPreservedAttributes;
}

global proc string[] sIBL_Maya_Arnold_storeSessionAttributes(string $sessionPreservedAttributes[])
{
	string $sessionStoredAttributes[] = {};
	for($attribute in $sessionPreservedAttributes)
		if(size(`ls $attribute`) )
		{
			$sessionStoredAttributes[size($sessionStoredAttributes)] = $attribute;
			$sessionStoredAttributes[size($sessionStoredAttributes)] =  `getAttr $attribute`;
		}
	return $sessionStoredAttributes;
}

global proc sIBL_Maya_Arnold_restoreSessionAttributes(string $sessionStoredAttributes[])
{
	for($i=0; $i<size($sessionStoredAttributes); $i+=2)
		if(size(`ls $sessionStoredAttributes[$i]`) )
		{
			float $value = $sessionStoredAttributes[$i + 1];
			setAttr $sessionStoredAttributes[$i] $value;
		}
}

global proc float sIBL_Maya_Arnold_getExtendedFeedbackRadius(float $feedbackRadius)
{
	float $sceneExtent = sIBL_Maya_Arnold_getSceneExtent();
	$sceneExtent = $sceneExtent * sqrt(2);
	$sceneExtent = $sceneExtent + ($sceneExtent * 10 / 100);

	if($sceneExtent < $feedbackRadius)
		return $feedbackRadius;
	else
		return sIBL_Maya_Arnold_truncFloatNumber($sceneExtent, 10);
}

global proc sIBL_Maya_Arnold_hideLights()
{
	SelectAllLights();
	if(size(`ls -sl`) != 0)
		HideSelectedObjects();
}

global proc sIBL_Maya_Arnold_deleteType(string $type, string $filter)
{
	string $types[] = `ls -type $type $filter`;
	if(size($types) != 0)
		delete($types);
}

global proc sIBL_Maya_Arnold_environmentDeletion()
{
	// sIBL Transform Group Deletion.
	string $sceneSIBLGroup[] = `ls -fl "sIBL"`;
	if($sceneSIBLGroup[0] != "")
	{
		delete($sceneSIBLGroup);
	}

	// sIBL ArnoldSkyShader Shaders Deletion.
	sIBL_Maya_Arnold_deleteType("ArnoldSkyShader", "sIBL*");

	// sIBL ArnoldRaySwitchShader Shaders Deletion.
	sIBL_Maya_Arnold_deleteType("ArnoldRaySwitchShader", "sIBL*");
	
	// sIBL shadingEngine Shaders Deletion.
	sIBL_Maya_Arnold_deleteType("shadingEngine", "sIBL*");

	// sIBL lambert Shaders Deletion.
	sIBL_Maya_Arnold_deleteType("lambert", "sIBL*");

	// sIBL file Shaders Deletion.
	sIBL_Maya_Arnold_deleteType("file", "sIBL*");

	// sIBL gammaCorrect Nodes Deletion.
	sIBL_Maya_Arnold_deleteType("gammaCorrect", "sIBL*");	
	
	// sIBL blendColors Nodes Deletion.
	sIBL_Maya_Arnold_deleteType("blendColors", "sIBL*");	
	
	// sIBL place2dTexture Shaders Deletion.
	sIBL_Maya_Arnold_deleteType("place2dTexture", "sIBL*");

	// sIBL Expressions Deletion.
	sIBL_Maya_Arnold_deleteType("expression", "sIBL*");
	
	// sIBL Condition Nodes Deletion.
	sIBL_Maya_Arnold_deleteType("condition", "sIBL*");
	
	// sIBL displayLayer Nodes Deletion.
	sIBL_Maya_Arnold_deleteType("displayLayer", "sIBL*");
}

global proc sIBL_Maya_Arnold_getMainLocator()
{
	string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();
	string $sIBLLocator = `createNode "annotationShape"`;
	
	setAttr ($sIBLLocator + ".displayArrow") 0;
	setAttr -lock true -keyable false ($sIBLLocator + ".displayArrow");
	setAttr -type "string" ($sIBLLocator + ".text") "[ Smart IBL Controls ]";
	
	string $sIBLLocatorTransform = sIBL_Maya_Arnold_getTransform($sIBLLocator);
	
	// Adding Attributes For Various Toggling And CC Controls.
	addAttr -ln "renderTogglers" -nn "[ Render Togglers ]" -at "enum" -en "Smart IBL" $sIBLLocatorTransform;
	setAttr -e-keyable true ($sIBLLocatorTransform + "." + "renderTogglers");
	setAttr -lock true ($sIBLLocatorTransform + "." + "renderTogglers");

	string $components[] = {"Background", "Reflection", "Lighting"};
	
	for($component in $components)
	{	
		addAttr -ln ("toggle" + $component)  -nn ($component) -at bool  $sIBLLocatorTransform;
		setAttr -e-keyable true ($sIBLLocatorTransform + (".toggle" + $component));
		setAttr ($sIBLLocatorTransform + (".toggle" + $component)) true;
	}
	
	string $controls[] = {"Gamma", "Gain"};

	for($component in $components)
	{	
		addAttr -ln ("cc" + $component) -nn ("[ " + $component + " CC ]") -at "enum" -en "Smart IBL" $sIBLLocatorTransform;
		setAttr -e-keyable true ($sIBLLocatorTransform + "." + ("cc" + $component));
		setAttr -lock true ($sIBLLocatorTransform + "." + ("cc" + $component));
		
		for($control in $controls)
		{
			string $lowerCaseComponent = `tolower $component`;
			addAttr -ln ($lowerCaseComponent + $control)  -nn $control -at double  $sIBLLocatorTransform;
			setAttr -e-keyable true ($sIBLLocatorTransform + "." + ($lowerCaseComponent + $control));
			setAttr ($sIBLLocatorTransform + "." + ($lowerCaseComponent + $control)) true;
		}
	}

	setAttr ($sIBLLocatorTransform + ".ty") 5;
	sIBL_Maya_Arnold_lockAttributes($sIBLLocatorTransform, {"rx", "ry", "rz", "sx", "sy", "sz"});

	parent $sIBLLocatorTransform $sIBLGroup;
	
	rename ("sIBL" + $sIBLLocatorTransform) "sIBL_Controls";
}

global proc sIBL_Maya_Arnold_getEnvironmentShadersBranch(string $skyShader, string $connectionEntries[], string $filePath, string $prefix, int $useOverride)
{
	string $file = `shadingNode -asTexture "file"`;	
	string $gammaCorrect = `shadingNode -asUtility "gammaCorrect"`;

	if($useOverride)
	{
		string $conditionNode = `shadingNode -asUtility "condition"`;
		setAttr ($conditionNode + ".secondTerm") 1;
		connectAttr -f ($gammaCorrect + ".outValue") ($conditionNode + ".colorIfTrue");
			
		string $blendColors = `shadingNode -asUtility "blendColors"`;
		setAttr ($blendColors + ".color1") -type double3 0 0 0 ;
		setAttr ($blendColors + ".color2") -type double3 0 0 0 ;
		setAttr ($blendColors + ".blender") 0;
		
		connectAttr -f ($blendColors + ".output") ($conditionNode + ".colorIfFalse");
		
		for($entry in $connectionEntries)
			connectAttr -f ($conditionNode + ".outColor") ($skyShader + "." + $entry);

		rename $conditionNode ($prefix + "_" + `nodeType $conditionNode`);
		rename $blendColors ($prefix + "_" + `nodeType $blendColors`);
	}
	else
	{
		for($entry in $connectionEntries)
			connectAttr -f ($gammaCorrect + ".outValue") ($skyShader + "." + $entry);
	}
	
	connectAttr -f ($file + ".outColor") ($gammaCorrect + ".value");
	
	string $place2dTexture = `shadingNode -asUtility "place2dTexture"`;

	connectAttr -f ($place2dTexture + ".outUV") ($file + ".uvCoord");
	connectAttr -f ($place2dTexture + ".outUvFilterSize") ($file + ".uvFilterSize");

	string $uvAttributes[] = {"coverage", "translateFrame", "rotateFrame", "mirrorU", "mirrorV", "stagger", "wrapU", "wrapV" , "repeatUV" , "vertexUvOne" , "vertexUvTwo" , "vertexUvThree" , "vertexCameraOne", "noiseUV", "offset", "rotateUV"};
	for($uvAttribute in $uvAttributes)
		connectAttr -f ($place2dTexture + "." + $uvAttribute) ($file + "." + $uvAttribute);

	setAttr -type "string" ($file + ".fileTextureName") $filePath;

	rename $file ($prefix + "_" + `nodeType $file`);
	rename $gammaCorrect ($prefix + "_" + `nodeType $gammaCorrect`);
	rename $place2dTexture ($prefix + "_" + `nodeType $place2dTexture`);
}

global proc sIBL_Maya_Arnold_getEnvironmentShaders(int $createBackground, int $createLighting, int $createReflection, string $backgroundFilePath, string $lightingFilePath, string $reflectionFilePath, int $visibility, int $useLightingForGlossy)
{
	string $skyShader = `shadingNode -asUtility "ArnoldSkyShader"`;
	setAttr ($skyShader + ".format") 2;
	setAttr ($skyShader + ".primary_visibility") 1;
	setAttr ($skyShader + ".skyRadius") 1;
	
	string $skyShaderTransform = sIBL_Maya_Arnold_getTransform($skyShader);
	string $locks[] = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"};
	sIBL_Maya_Arnold_lockAttributes($skyShaderTransform, $locks);

	setAttr ($skyShaderTransform + ".visibility") $visibility;
	
	string $raySwitch = `shadingNode -asUtility "ArnoldRaySwitchShader"`;
	connectAttr -f ($raySwitch + ".message") ($skyShader + ".color");

	string $connectionEntries[] = {};
	if($createBackground)
	{
		$connectionEntries = {"camera", "refraction"};
		sIBL_Maya_Arnold_getEnvironmentShadersBranch($raySwitch, $connectionEntries, $backgroundFilePath, "sIBL_Background", 1);
	}

	if($createLighting)
	{
		if($useLightingForGlossy)
			$connectionEntries = {"diffuse", "glossy"};
		else
			$connectionEntries = {"diffuse"};			
		sIBL_Maya_Arnold_getEnvironmentShadersBranch($raySwitch,  $connectionEntries, $lightingFilePath, "sIBL_Lighting", 1);
	}

	if($createReflection)
	{
		if($useLightingForGlossy)
			$connectionEntries = {"reflection"};
		else
			$connectionEntries = {"reflection", "glossy"};
		sIBL_Maya_Arnold_getEnvironmentShadersBranch($raySwitch, $connectionEntries, $reflectionFilePath, "sIBL_Reflection", 1);
	}

	connectAttr -f ($skyShader + ".message") "defaultArnoldRenderOptions.background";
	
	string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();
	string $skyHook = `createNode transform`;
	for($lock in $locks)
		setAttr -keyable false ($skyHook + "." + $lock);

	string $skyShaderTransforms[] = `parent  $skyShaderTransform $skyHook`;
	$skyShaderTransform = $skyShaderTransforms[0];
	
	string $skyHookTransforms[] = `parent  $skyHook $sIBLGroup`;
	$skyHook = $skyHookTransforms[0];
	
	rename $skyShader ("sIBL_" + `nodeType $skyShader`);
	rename $skyHook ("sIBL_Sky_Hook");
	rename $skyShaderTransform ("sIBL_Sky");
	rename $raySwitch ("sIBL_" + `nodeType $raySwitch`);
}

global proc string sIBL_Maya_Arnold_getSIBLGroup()
{
	string $sIBLGroup[] = `ls -fl "sIBL"`;
	if($sIBLGroup[0] == "")
	{
		$sIBLGroup[0] = `createNode "transform" -n "sIBL"`;
		sIBL_Maya_Arnold_lockAttributes($sIBLGroup[0], {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"});
	}

	return $sIBLGroup[0];
}

global proc string sIBL_Maya_Arnold_getFeedbackGeometry(float $feedbackRadius, int $feedBackVisibility)
{
 	string $feedback[] = `sphere -name "sIBL_Feedback"`;
	rebuildSurface -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 4 -du 3 -sv 8 -dv 3 -tol 0.01 -fr 0  -dir 2 $feedback;
	delete -ch;

	setAttr ($feedback[0] + ".scaleZ") (-1);
	makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $feedback[0];

	string $scaleAttributes[] = {"scaleX", "scaleY", "scaleZ"};
	for($scaleAttribute in $scaleAttributes)
		setAttr ($feedback[0] + "." + $scaleAttribute) $feedbackRadius;

	setAttr ($feedback[0] + ".rotateZ") 90;

	sIBL_Maya_Arnold_lockAttributes($feedback[0], {"tx", "ty", "tz"});
	
	setAttr ($feedback[0] + ".visibility") $feedBackVisibility;

	string $feedBackShapes[] = sIBL_Maya_Arnold_getShapes($feedback[0]);
	string $renderStats[] = {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions", "doubleSided", "opposite"};
	for($stat in $renderStats)
		setAttr ($feedBackShapes[0] + "." + $stat) false;

	sIBL_Maya_Arnold_addToDisplayLayer("sIBL_Feedback_Layer", $feedback[0]);

	return $feedback[0];
}

global proc sIBL_Maya_Arnold_getFeedback(string $backgroundFilePath, float $feedbackRadius, int $feedBackVisibility)
{
 	string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();
	string $feedback = sIBL_Maya_Arnold_getFeedbackGeometry($feedbackRadius, $feedBackVisibility);
	parent $feedback $sIBLGroup;

	string $lambertShader = `shadingNode -asShader "lambert"`;
	setAttr ($lambertShader + ".transparency") -type double3 0.5 0.5 0.5 ;
	string $shadingEngine = `sets -renderable true -noSurfaceShader true -empty`;
	sets -renderable true -noSurfaceShader true -empty -name $shadingEngine;
	connectAttr -f ($lambertShader + ".outColor") ($shadingEngine + ".surfaceShader");

	string $file = `shadingNode -asTexture "file"`;
	if(!`attributeExists "resolution" $file`)
		addAttr -ln "resolution" -at long $file;
 	setAttr  ($file + ".resolution") 2048;

	setAttr -type "string" ($file + ".fileTextureName") $backgroundFilePath;

	connectAttr -f ($file + ".outColor") ($lambertShader + ".color");

	string $place2dTexture = `shadingNode -asUtility "place2dTexture"`;

	connectAttr -f ($place2dTexture + ".outUV") ($file + ".uvCoord");
	connectAttr -f ($place2dTexture + ".outUvFilterSize") ($file + ".uvFilterSize");

	string $uvAttributes[] = {"coverage", "translateFrame", "rotateFrame", "mirrorU", "mirrorV", "stagger", "wrapU", "wrapV" , "repeatUV" , "vertexUvOne" , "vertexUvTwo" , "vertexUvThree" , "vertexCameraOne", "noiseUV", "offset", "rotateUV"};
	for($uvAttribute in $uvAttributes)
		connectAttr -f ($place2dTexture + "." + $uvAttribute) ($file + "." + $uvAttribute);

	setAttr ($place2dTexture + ".rotateFrame") 90;

	sets -e -forceElement $shadingEngine $feedback;

	rename $lambertShader ("sIBL_Feedback_" + `nodeType $lambertShader`);
	rename $shadingEngine ("sIBL_Feedback_" + `nodeType $shadingEngine`);
	rename $file ("sIBL_Feedback_" + `nodeType $file`);
	rename $place2dTexture ("sIBL_Feedback_" + `nodeType $place2dTexture`);
}

global proc string sIBL_Maya_Arnold_getLigthsTargetLocator()
{
	string $sIBL_Lights_Target_Locator[] = `ls -fl "sIBL_Lights_Target_Locator"`;

	if($sIBL_Lights_Target_Locator[0] == "")
	{
		string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();

		$sIBL_Lights_Target_Locator = `spaceLocator`;
		parent $sIBL_Lights_Target_Locator[0] $sIBLGroup;

		rename $sIBL_Lights_Target_Locator[0] "sIBL_Lights_Target_Locator";
	}

	$sIBL_Lights_Target_Locator = `ls -fl "sIBL_Lights_Target_Locator"`;
	
	sIBL_Maya_Arnold_addToDisplayLayer("sIBL_Lighting_Layer", $sIBL_Lights_Target_Locator[0]);

	return $sIBL_Lights_Target_Locator[0];
}

global proc sIBL_Maya_Arnold_getLight(string $type, string $name, float $scale, float $color[], float $intensity, float $lightAngle, float $uCoordinate, float $vCoordinate)
{
	switch($type)
	{
		case "Area":
			string $primitiveType = "areaLight";
			break;
		case "Directional":
			string $primitiveType = "directionalLight";
			break;
		case "Point":
			string $primitiveType = "pointLight";
			break;
		case "Spot":
			string $primitiveType = "spotLight";
			break;
	}

	string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();
	string $feedback[] = `ls -fl "sIBL_Feedback"`;

	string $light = `shadingNode -asLight $primitiveType`;

	setAttr -type double3 ($light + ".color") ($color[0] / 255) ($color[1] / 255) ($color[2] / 255);
	setAttr ($light + ".intensity") $intensity;
	setAttr ($light + ".useRayTraceShadows") 1;
	
	switch($type)
	{
		case "Area":
			setAttr($light + ".areaLight") 1;
			break;
		case "Directional":
			break;
		case "Point":
			break;
		case "Spot":
			setAttr($light + ".coneAngle") 96;
			setAttr($light + ".penumbraAngle") 16;
			break;
	}

	if($type == "Area")
		$scale = $scale / 2;
	for($attribute in {"sx", "sy", "sz"})
		setAttr ($light + "." + $attribute) $scale;

	parent $light $sIBLGroup;

	string $pointOnSurfaceInfo = `createNode "pointOnSurfaceInfo"`;
	connectAttr -f ($feedback[0] + "Shape.worldSpace[0]") ($pointOnSurfaceInfo + ".inputSurface");
	connectAttr -f ($pointOnSurfaceInfo + ".position") ($light + ".translate");

	setAttr ($pointOnSurfaceInfo + ".parameterU") (0.5 + (0.5 - $vCoordinate));
	setAttr ($pointOnSurfaceInfo + ".parameterV") (0.5 + (0.5 - $uCoordinate));

	string $sIBL_Lights_Target_Locator = sIBL_Maya_Arnold_getLigthsTargetLocator();

	string $constraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $sIBL_Lights_Target_Locator $light`;

	sIBL_Maya_Arnold_addToDisplayLayer("sIBL_Lighting_Layer", $light);

	rename $light $name;
	rename $pointOnSurfaceInfo ($name + "_" + `nodeType $pointOnSurfaceInfo`);
	rename $constraint[0] ($name + "_" + `nodeType $constraint[0]`);
}

global proc sIBL_Maya_Arnold_getSun(string $sunLightType, float $sunU, float $sunV, float $sunColor[], float $sunMultiplier, float $feedbackRadius)
{
	sIBL_Maya_Arnold_getLight($sunLightType, "sIBL_Sun", ($feedbackRadius / 15), $sunColor, $sunMultiplier, 1.5, $sunU, $sunV);
}

global proc sIBL_Maya_Arnold_getDynamicLights(string $dynamicLightsType, string $compactedDynamicLights, float $feedbackRadius)
{
	string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();
	string $feedback[] = `ls -fl "sIBL_Feedback"`;

	string $dynamicLights[];
	tokenize($compactedDynamicLights, "|", $dynamicLights);

	for($i=0; $i<size($dynamicLights); $i+=8)
	{
		float $color[] = {float($dynamicLights[$i + 2]), float($dynamicLights[$i + 3]), float($dynamicLights[$i + 4])};
		sIBL_Maya_Arnold_getLight($dynamicLightsType, "sIBL_DKL_" + $dynamicLights[$i + 1], ($feedbackRadius / 15), $color, float($dynamicLights[$i + 5]), 0, float($dynamicLights[$i + 6]), float($dynamicLights[$i + 7]));
	}
}

global proc sIBL_Maya_Arnold_bridgeFeedbackControlsAndShaders(string $target)
{
	/* TODO: Remove When MtoA Exports The Connections  Properly */
	//connectAttr -f ("sIBL_Controls.toggle" + $target)  ("sIBL_" + $target + "_condition.firstTerm") ;
	setAttr ("sIBL_" + $target + "_condition.firstTerm") 1 ;
	string $lowerCaseTarget = `tolower $target`;
		
	string $gammaSubComponents[] = {"X", "Y", "Z"};
	for($gammaSubComponent in $gammaSubComponents) 
	{
		connectAttr -f ("sIBL_Controls." + $lowerCaseTarget + "Gamma") ("sIBL_" + $target + "_gammaCorrect.gamma" + $gammaSubComponent);
	}
		
	string $gainSubComponents[] = {"R", "G", "B"};
	for($gainSubComponent in $gainSubComponents) 
	{
		connectAttr -f ("sIBL_Controls." + $lowerCaseTarget + "Gain") ("sIBL_" + $target + "_file.colorGain" + $gainSubComponent);
	}
}

global proc sIBL_Maya_Arnold_connectFeedbackToSIBLShaders(string $feedback, int $connectToBackground, int $connectToLighting, int $connectToReflection)
{
	string $skyShaderTransform = sIBL_Maya_Arnold_getObject("sIBL_Sky_Hook");
	string $parentConstraint[] = `parentConstraint -mo -weight 1 $feedback $skyShaderTransform`;
	string $scaleConstraint[] = `scaleConstraint -weight 1 $feedback $skyShaderTransform`;
	
	rename $parentConstraint[0] ($skyShaderTransform + "_" + `nodeType $parentConstraint[0]`);
	rename $scaleConstraint[0] ($skyShaderTransform + "_" + `nodeType $scaleConstraint[0]`);

	if($connectToBackground)
		sIBL_Maya_Arnold_bridgeFeedbackControlsAndShaders("Background");

	if($connectToLighting)
		sIBL_Maya_Arnold_bridgeFeedbackControlsAndShaders("Lighting");

	if($connectToReflection)
		sIBL_Maya_Arnold_bridgeFeedbackControlsAndShaders("Reflection");
}

global proc sIBL_Maya_Arnold_activateLinearWorkflow(int $createBackground)
{
	float $defaultGammaValue = 2.2;

	setAttr "defaultArnoldRenderOptions.driver_gamma" $defaultGammaValue;
	setAttr "defaultArnoldRenderOptions.light_gamma" $defaultGammaValue;
	setAttr "defaultArnoldRenderOptions.shader_gamma" $defaultGammaValue;
	setAttr "defaultArnoldRenderOptions.texture_gamma" $defaultGammaValue;

	// Adjust Background Color Space Because Of The Tonemapper
	if($createBackground)
		setAttr  "sIBL_Controls.backgroundGamma" (1 / $defaultGammaValue);
}

global proc sIBL_Maya_Arnold_getGround(float $feedbackRadius)
{
	string $sIBLGroup = sIBL_Maya_Arnold_getSIBLGroup();
	string $ground[] = `polyPlane -sx 15 -sy 15`;
	delete -ch;

	setAttr ($ground[0] + ".overrideEnabled") 1;
	setAttr ($ground[0] + ".overrideShading") 0;

	string $scaleAttributes[] = {"scaleX", "scaleY", "scaleZ"};
	for($scaleAttribute in $scaleAttributes)
		setAttr ($ground[0] + "." + $scaleAttribute) ($feedbackRadius * sqrt(2));

	parent $ground[0] $sIBLGroup;
	
	sIBL_Maya_Arnold_addToDisplayLayer("sIBL_Ground_Layer", $ground[0]);
	
	rename $ground[0] "sIBL_Ground";		
}

global proc sIBL_Maya_Arnold_activateArnold()
{
	if(`pluginInfo -q -loaded "mtoa"` == 0)
	{
		loadPlugin("mtoa");
	}
	setAttr defaultRenderGlobals.currentRenderer -type "string" "arnold";
	python("import mtoa.cmds.registerArnoldRenderer; mtoa.cmds.registerArnoldRenderer.registerArnoldRenderer()");
}

global proc sIBL_Maya_Arnold_lockAttributes(string $node, string $attributes[])
{
	for($attribute in $attributes)
		setAttr -lock true -keyable false ($node + "." + $attribute);
}

global proc float sIBL_Maya_Arnold_getSceneExtent()
{
	string $geometries[] = `ls -l -geometry`;
	string $transforms[] = {};

	for($geometry in $geometries)
		$transforms[size($transforms)] = sIBL_Maya_Arnold_getTransform($geometry);
	    
	float $sceneExtent = 0;
	for($transform in $transforms)
	{
		float $boundingBox[] = `xform -q -bb $transform`;
			
		for($i=0; $i < size($boundingBox); $i++)
			if(abs($boundingBox[$i]) > $sceneExtent)
				$sceneExtent = abs($boundingBox[$i]);
	}
	return $sceneExtent;
}

global proc float sIBL_Maya_Arnold_truncFloatNumber(float $number, float $truncValue)
{
	if($truncValue != 0)
		return `trunc ($number / $truncValue)` * $truncValue; 
	else
		return $number;
}

global proc string[] sIBL_Maya_Arnold_getShapes(string $xform)
{
	string $shapes[];
	$shapes[0] = $xform;
	if("transform" == `nodeType $xform`)
		$shapes = `listRelatives -fullPath -shapes $xform`;
	return $shapes;
}

global proc string sIBL_Maya_Arnold_getTransform(string $shape)
{
	string $transform = "";
	if("transform" != `nodeType $shape`)
	{
		string $parents[] = `listRelatives -fullPath -parent $shape`;
		$transform = $parents[0];
	}
	return $transform;
}

global proc int sIBL_Maya_Arnold_objectExists(string $object, string $errorMessage)
{
	string $objects[] = `ls -fl $object`;
	if($objects[0] != "")
	{
		return 1;
	}
	else
	{
		error($errorMessage);
		return 0;
	}
}

global proc string sIBL_Maya_Arnold_getObject(string $object)
{
	string $list[] = `ls -fl $object`;
	return $list[0];
}

global proc string sIBL_Maya_Arnold_addToDisplayLayer(string $layerName, string $object)
{
	string $layer = sIBL_Maya_Arnold_getObject($layerName);
	if($layer == "")
		$layer = `createDisplayLayer -name $layerName`;
	editDisplayLayerMembers -noRecurse $layer $object;
	return $layer;
}

global proc string[] sIBL_Maya_Arnold_filterNonExistingNodes(string $nodes[])
{
	string $filteredNodes[];
	for($node in $nodes)
	if(`objExists($node)`)
		$filteredNodes[size($filteredNodes)] =  $node;
	return $filteredNodes;
}